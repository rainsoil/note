#   `JVM`之`Garbage Collect(垃圾回收)`



##  1 如何确定一个对象是垃圾

要想进行垃圾回收,得先知道什么样的对象是垃圾. 

###  1.1 引用计数法

对于某个对象而言,只要应用程序中持有该对象的引用,就说明该对象不是垃圾,如果一个对象没有任何指针对其引用, 就说明他是个垃圾. 

**弊端:** 如果AB 互相持有引用,导致永远不能被回收. 

### 1.2  可达性分析

通过`GC Root` 对象,开始向下寻找, 看某个对象是否可达. 

> 能作为`GC Root`:  类加载器、`Thread`、虚拟机栈的本地变量表、`static` 成员、常量引用、本地方法栈的变量等. 

## 2 垃圾收集算法

已经能够确定一个对象为垃圾后,接下来要考虑的就是回收, 怎么回收呢? 

得要有对应的算法,下面聊聊常见的垃圾回收算法. 

### 2.1 标记-清除算法(`Mark-Sweep`)

- **标记**

  找出内存中需要回收的对象,并且把他们标记出来. 

  > 此时堆中所有的对象都会被扫描一遍,从而才能确定需要回收的对象,比较耗时. 

  ![image-20200508135841438](http://files.luyanan.com//img/20200508135842.png)

- 清除

  清除掉被标记的需要回收的对象，释放出相应的内存空间. 

  ![image-20200508135957095](http://files.luyanan.com//img/20200508135958.png)

 

**缺点:**

标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致以后的程序运行过程中需要分配较大的对象的时候, 无法找到足够的连续内存而不得不提前触发另一次垃圾收集的动作. 

1. 标记和清除两个过程都比较耗时,效率不高.
2. 会产生大量的不连续的内存碎片,空间碎片太对会导致以后再程序运行过程中需要分配较大对象的时候,无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作. 



### 2.2 复制(`Copying`)

将内存划分为两块相等的区域, 每次只使用一块,如下图所示: 

![image-20200508140616615](http://files.luyanan.com//img/20200508140617.png)

当其中一块内存使用完了后,就将还存活的对象复制到另外一块上面,然后把已经使用过的内存空间一次清除掉. 

![image-20200508140722350](http://files.luyanan.com//img/20200508140724.png)

**缺点:**  空间利用率低

### 2.3 标记-整理(`Mark-Compact`)

标记过程中仍然与"标记-清除"算法一样,但是后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉边界以外的内存. 

![image-20200508141625646](http://files.luyanan.com//img/20200508141626.png)

让所有存活的对象都向一端移动,清理掉边界以外的内存. 

![image-20200508141709909](http://files.luyanan.com//img/20200508141710.png)



## 3. 分代收集算法

既然上面介绍了3种垃圾收集算法,那么在堆内存中到底用哪一个呢? 

`Young`区: 复制算法(对象在被分配后, 可能生命周期比较短,`Young` 区复制效率比较高)

`Old`区: 标记清除或者标记整理(`Old` 区对象存活时间比较长, 复制来复制去没必要, 不如做个标记再清理)



##  4. 垃圾收集器

如果收集算法是内存回收的方法论,那么垃圾收集器就是垃圾回收的具体实现,说白了就是落地. 

![image-20200508142730624](http://files.luyanan.com//img/20200508142731.png)

###  4.1 `Serial`  收集器

`Serial` 收集器是最基本、发展历史最悠久的收集器,曾经(`JDK1.3.1之前`)是虚拟机新生代收集的唯一选择. 

它是一种单线程的收集器,不仅仅意味着它只会使用一个CPU 或者一条收集线程去完成垃圾收集工作,更重要的是其在进行垃圾收集的时候需要暂停其他线程. 

> **优点:**简单高效, 拥有很高的单线程收集效率
>
> **缺点:** 收集过程中需要暂停所有线程
>
> **算法:** 复制算法
>
> **使用范围:** 新生代
>
> **应用:** `Client` 模式下的默认新生代收集器

![image-20200508143300787](http://files.luyanan.com//img/20200508143301.png)



### 4.2 `ParNew` 收集器

可以把这个收集器理解为`Serial` 收集器的的多线程版本

> **优点:** 在多`CPU`的时候,比`Serial`效率高
>
> **缺点:** 收集过程中暂停所有应用程序线程,单CPU时比`Servial` 效率慢
>
> **算法**: 复制算法
>
> **适用范围:** 新生代
>
> **应用:** 运行在`Server`  模式下的虚拟机中首选的新生代收集器

![image-20200508145226936](http://files.luyanan.com//img/20200508145227.png)



### 4.3 `Paraller Scavenge` 收集器

`Parallel Scavenge`收集器是一个新生代我收集器, 它也是使用复制算法的收集器,又是并行的多线程收集器, 看上去和`ParNew` 一样,但是 `Paraller Scavenge`  更加关注`系统吞吐量`

> 吞吐量= 运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)
>
> 比如虚拟机总共运行了100分钟, 垃圾收集时间用了1分钟, 吞吐量=(100-1)/100 = 99%
>
> 若吞吐量越大, 意味着垃圾收集的时间越短,则用户代码可以充分利用用CPU资源,尽快完成程序的运算任务. 

```java
-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， 
-XX:GCTimeRatio直接设置吞吐量的大小。
```



### 4.4 `Serial Old` 收集器

`Serial Old` 收集器是`Serial` 收集器的老年代版本,也是一个单线程收集器, 不同的是采用"标记-整理" 算法,运行过程跟`Serial`是一样的. 

![image-20200508153742323](http://files.luyanan.com//img/20200508153743.png)



### 4.5 `Paraller Old` 收集器

`Paraller Old` 收集器是`Paraller Scavenge` 收集器的老年代版本,使用多线程和"标记-整理"算法进行垃圾收集. 

**使用场景:** 吞吐量优先



### 4.6 `CMS` 收集器

`CMS(Concurrent Mark Sweep)` 收集器是一种以获取`最短回收停顿时间` 为目标的收集器. 

采用的是"标记-清除"算法, 整个过程分为4步: 

1. 初始标记 `CMS initial mark`  -> 标记`GC Roots`能关联的对象 -> `Stop The World`(速度很快)
2. 并发标记 `CMS concurrent mark` -> 进行`GC Roots Tracing`
3. 重新标记 `CMS remark` 修改并发标记因用户程序变动的内容 `Stop The World`
4. 并发清除 `CMS concurrent sweep`



整个过程中, 并发标记和并发清除,收集器线程可以与工作线程一起工作,所以总体上来说,`CSM` 收集器的内存回收过程是与用户线程一起并发的执行的. 

> **优点:** 并发收集、低停顿
>
> **缺点:** 会产生大量空间碎片、并发阶段会降低吞吐量.

![image-20200508155021813](http://files.luyanan.com//img/20200508155022.png)



### 4.7  `G1` 收集器

`G1`的特点: 

- 并行与并发
- 分代收集(仍然保留了分代的概念)
- 空间整合(整体上属于"标记-整理"算法,不会导致空间碎片)
- 可预测的停顿(比`CMS` 更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内,消耗在垃圾收集器上的时间不得超过M毫秒)



使用`G1` 收集器时,java堆的内存布局就与其他收集器有很大的差别, 它将整个java堆划分为多个大小相等的独立区域(`Region`), 虽然还保留有新生代和老年代的概念,但新生代和老年代不再是物理隔离,他们都是一部分`Region`(不需要连续)的集合.

工作过程可以分为以下几步:

初始标记(`Initial Marking`): 标记一下`GC Roots` 能够关联的对象,并且修改`TAMS`的值,需要暂停用户线程

并发标记(`Concurrent Marking`): 从`GC Roots`  进行可达性分析,找出存活的对象,与用户线程并发执行. 

最终标记(`Final Marking`):  修改正在并发标记节点因为用户程序的并发执行导致变动的数据,需要暂停用户线程

筛选回收(`Live Data Counting and Evacuation`): 对各个`Region`的回收价值和成本进行排序,根据用户所期望的`GC` 停顿时间制定回收计划. 



![image-20200508160201527](http://files.luyanan.com//img/20200508160203.png)



### 4.8 垃圾收集器分类

- 串行收集器 -> `Serial` 和`Serial Old`

   只能有一个垃圾回收线程执行,用户线程暂停, `适用于内存比较小的嵌入式设备`

- 并行收集器[吞吐量优先] -> `Paraller Scanvenge` 、`Paraller Old`

   多条垃圾收集线程并行工作,但是此时用户线程仍然处于等待状态 `适用于科学计算、后台处理等弱交互场景`

- 并行收集器[停顿时间优先]: ->`CMS`、`G1` 

   用户线程和垃圾收集线程同时执行(但并不一定是并行,可能是交替执行). 垃圾收集线程在执行的时候不会停顿用户线程的运行. `适用于相对时间有要求的场景, 比如`web`



### 4.9  理解吞吐量和停顿时间

 **停顿时间**: 垃圾收集器进行垃圾回收终端应用执行响应的时间

**吞吐量**: 运行用户代码时间/(运行用户代码时间+垃圾收集时间)

> 停顿时间越短就越适合需要和用户交互的场景,良好的响应速度能提升用户体验. 
>
> 高吞吐量则可以高效的利用CPU时间,尽快完成程序的运算任务,只要使用在后台运算并且不需要太多交互的任务. 

**小结**: 这两个指标也是评价垃圾回收期好坏的标准,其实调优也是在观察这两个变量. 



### 4.10 如何选择合适的垃圾收集器

`官网`: https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28

- 优先调整堆的大小让服务器自己来选择
- 如果内存小于100M , 使用串行收集器
- 如果是单核,并且没有停顿时间要求,使用串行或者JVM 自己选
- 如果允许停顿时间超过1s, 选择并行或JVM 自己选
- 如果响应时间最重要, 并且不能超过1s,使用并发收集器
- 对于G1收集器



### 4.11 再次理解G1

`jdk7`开始使用,`JDK8` 已经成熟, `JDK9`默认的垃圾收集器, 适用于新老年代

判断是否需要使用G1 收集器

1. 50% 以上的堆被存活对象占用
2. 对象分配和晋升的速度变化非常大
3. 垃圾回收时间比较长



### 4.12 如何开启需要的垃圾收集器

```bash
（1）串行
    -XX：+UseSerialGC 
    -XX：+UseSerialOldGC 
(2)并行(吞吐量优先)：
    -XX：+UseParallelGC
    -XX：+UseParallelOldGC 
 (3)并发收集器(响应时间优先)
    -XX：+UseConcMarkSweepGC
    -XX：+UseG1GC
```

