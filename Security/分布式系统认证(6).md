# 分布式系统认证方案

## 1. 什么是分布式系统

随着软件环境和需求的变化,软件的架构由单体结构演变为分布式架构,具有分布式架构的系统叫做分布式系统, 分布式系统的运行通常依靠网络, 他将单体结构的系统分为若干服务, 服务之间通过网络交互来完成用户的业务处理, 当前流行的微服务架构就是分布式系统的结构,如下图:

![image-20200729092813897](6.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200729092813897.png)

分布式系统具体如下基本特点:

1. **分布式:** 每个部分都可以独立部署,服务之间交互通过网络进行通信,比如:订单服务、商品服务
2. **伸缩性:** 每个部分都可以集群方式部署,并可针对部分节点进行硬件和软件扩容,具有一定的伸缩能力, 
3. **共享性:** 每个部分都可以作为共享资源并对外提供服务,多个部分可能有操作共享资源的情况
4. **开放性:** 每个部分根据需求都可以对外发布共享资源的访问接口, 并可允许第三方系统访问.

## 2  分布式纷争需求

分布式系统的每个服务的都会有认证,授权的需求，如果每个服务都实现一套认证授权逻辑会非常冗余,考虑到分布式系统共享性的特点,需要由独立的认证服务处理系统认证授权的请求,考虑分布式系统开放性的特点,不仅对系统内部服务提供认证,对第三放系统也要提供认证. 分布式认证的需求如下:

### 2.1 统一认证授权

提供独立的认证服务,统一处理认证授权

无论是不同类型的用户,还是不同种类的客户端(`web`端,`H5`、`APP`),均采用一致的认证,权限、会话机制,实现统一认证授权. 

要实现统一则认证方式必须可扩展,支持各种认证需求,比如:用户名密码认证、短信验证码、二维码、人脸识别等认证方式,并可以非常灵活的却换, 

### 2.2 应用接入认证

应提供扩展和开放能力,提供安全的系统对接机制,并可开放部分`API`给接入第三方使用,一方应用(内部系统服务)和三方应用(第三方应用) 均采用统一机制接入. 

## 3. 分布式认证方案

### 3.1 选型分析

#### 3.1.1 基于`session` 的认证方式

在分布式环境下,基于`session` 的认证会出现一个问题,每个应用服务都需要在`session` 中存储用户身份信息,通过负载均衡将本地的请求分配到另外一个应用服务需要将`session` 信息带过去,否则会重新认证

![image-20200729092828596](6.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200729092828596.png)

这个时候,通常的做法有下面几种:

**`session`复制:** 多台应用服务器之间同步`session`, 使`session` 保持一致,对外透明

**`session` 黏贴:** 当用户访问集群中某台服务器后,强制指定后续所有请求均落到此机器上.

**`session` 集中存储:** 将`session` 存入分布式缓存中, 所有服务器应用实例统一从分布式缓存中存取`session`

总体来说,基于`session` 认证的认证方式, 可以更好的在服务端对会话进行控制, 且安全性较高。但是,`session` 机制方式基于`cookie`, 在复杂多样的移动客户端上不能有效的使用,并且无法跨域,另外随着系统的扩展需提高`session`的复制、黏贴、存储的容错性. 

#### 3.1.2 基于`token`的认证方式

基于`token`的认证方式,服务端不用存储认证数据,易维护扩展性强, 客户端可以把`token` 存在任意地方,并且可以实现`web` 和`app` 统一认证机制. 其缺点也很明显,`token`由于自包含信息,因此一般数据量较大, 并且每次请求都需要传递,因此比较占带宽. 另外，`token` 的签名验签操作也会给`cpu` 带来额外的处理负担. 

![image-20200729092837928](6.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200729092837928.png)

### 3.2 技术方案

根据选型的分析,一般采用基于`token`的认证方式,它的优点是:

1. 适合统一认证的机制, 客户端、一方应用、三方应用都遵循一致的认证方案
2. `token`认证方式对第三方应用接入更适合,因为它更开放, 可使用当前有流行的开放协议`Oauth2.0`、`JWT`等. 
3. 一般情况服务端无需存储会话信息,减轻了服务端的压力. 

分布式系统认证技术方案见下图:

![image-20200729092848445](6.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200729092848445.png)

流程描述:

1. 用户通过接入方(应用)登陆, 接入方采用`Oauth2.0`方式 在统一认证服务(`UAA`) 中认证
2. 认证服务(`UAA`) 调用验证该用户的身份是否合法, 并获取用户权限信息
3. 认证服务(`UAA`) 获取接入方权限信息,并验证接入方是否合法. 
4. 若登陆用户以及接入方都合法,认证服务生成`jwt` 令牌返回给接入方,其中`jwt` 中包含了用户权限以及接入方权限. 
5. 后续, 接入方携带`jwt` 令牌对`API` 网关内的微服务资源进行访问. 
6. `API` 网关对令牌解析,并验证接入方的权限是否能够访问本次请求的微服务
7. 如果接入方的权限没有问题,`API`网关将原请求`header` 中附加解析后的明文`token`,并将请求转发至微服务
8. 微服务收到请求,明文`token` 中包含登录用户的身份信息和权限信息,因此后续微服务自己可以干两件事情:
   1. 用户授权拦截(看当前用户是否有权限访问该资源)
   2. 将用户信息存储到当前线程上下文中(有利于后续业务逻辑随时获取当前用户信息)

流程所涉及到`UAA`服务、`API` 网关服务、这些组件的职责如下: 

 **统一认证服务`UAA` **

> 它承载了`Oauth2.0` 接入方认证、登入用户的认证、授权以及生成令牌的职责, 完成实际的用户认证、授权哦功能

**`API` 网关**

作为系统唯一的入口, `API` 网关为接入方提供定制的`API` 集合,它可能还具体有其他职责,如验证、监控、负载均衡、缓存等. `API` 网关方式的核心要点是所有的接入方和消费端都通过统一的网关接入服务，在网关层处理所有的非业务处理. 



## 4. `Oauth2.0`

`Oauth`（开放授权）是一个开放标准,允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息,而不需要将用户名和密码提供给第三方应用或者分享他们数据的所有内容.`Oauth2.0` 是`Oauth`协议的延续版本,但不向后兼容`Oauth1.0`,即完全废止了`Oauth1.0`. 很多大公司比如`Google`、`Yahoo`等都提供了`Oauth` 认证服务,这些都足以说明`Oauth` 标准逐渐成为开放资源授权的标准. 

参考: https://baike.baidu.com/item/oAuth/7153134?fr=aladdin

`Oauth`协议: https://tools.ietf.org/html/rfc6749

下面分析一个`Oauth2.0` 认证的例子,通过例子去理解`Oauth2.0`协议的认证流程,本例子是`gitee` 网站使用微信去认证的过程, 这个过程简单的描述如下： 

用户借助微信认证登录码云网站,用户就不需要单独在码云网站上注册用户,怎么样才算认证成功呢? 码云网站需要成功从微信获取用户的身份信息则视为用户认证成功,那如何获取微信的用户信息呢? 用户信息的拥有者是用户本人,微信需要经过用户的同意方可为码云网站生成令牌,码云网站拿到此令牌方可从微信获取用户信息. 

1. 客户端请求第三方授权

   用户进入码云的登录页面, 点击微信的图标进入微信账号登陆系统,用户是自己微信信息的资源拥有者

   ![image-20200729111804996](6.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200729111804996.png)

点击微信, 出现一个二维码,此时用户扫描二维码就开始给码云授权

![image-20200729124934032](6.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200729124934032.png)

2. 资源拥有者同意给客户端授权

    资源拥有者扫描二维码表示资源拥有者同意给客户端授权,微信会对资源拥有者的身份进行验证,验证通过后,微信会询问用户是否给授权码云访问自己的微信数据,用户点击"确认登录" 表示同意授权,微信认证服务器会颁发一个授权码,并重定向到码云的网站.

   

3. 客户端获取到授权码, 请求认证服务器申请令牌

    此过程用户看不到,客户端从应用程序请求认证服务器,请求携带授权码

4. 认证服务器向客户端响应令牌
    微信认证服务器验证了客户端请求的授权码,如果合法则给客户端颁发令牌, 令牌是客户端访问资源的通行证,此交互过程用户看不到,当客户端拿到令牌后,用户在码云网站看已经登录成功了. 
    
5. 客户端请求资源服务器的资源

     客户端携带令牌访问资源服务器的资源

    码云网站写到令牌请求访问微信服务器获取用户的基本用户信息

6. 资源服务器返回受保护的资源

    资源服务器校验令牌的合法性,如果合法则向用户响应资源信息内容



通过上面的例子,我们已经大致了解了`Oauth2.0` 的认证过程,下面我们看`Oauth2.0`的认证过程

引自`Oauth2.0`协议`rfc6749` https://tools.ietf.org/html/rfc6749

![image-20200729164939599](6.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200729164939599.png)

 `Oauth2.0` 包括以下角色:

1. 客户端

    本身不存储资源,需要通过资源拥有者的授权去请求资源服务器的资源,比如`Android` 客户端,`web` 客户端,微信客户端 

2. 资源拥有者

    通常为用户,也可以是应用程序,即该资源的拥有者

3. 授权服务器(也成为认证服务器)

   用于服务提供商对资源拥有者的身份进行认证,对访问资源进行授权,认证成功后会给客户端发放令牌(`access_token`),作为客户端访问资源服务器的凭据,本例中微信为认证服务器.

4. 资源服务器

   存储资源的服务器,本例子为微信存储的用户信息

   现在还有一个问题,服务提供商能允许随便一个客户端就接入到它的授权服务商吗? 答案是否定的,服务提供商会给准入的接入方一个身份,用户接入的凭据

   `client_id` 客户端标识

   `client_secret`: 客户端秘钥

   因此,准确的来说,授权服务器对两种`Oauth2.0` 中的两个角色进行认证授权,分别是资源拥有者和客户端. 

   

   

   

    

   

   