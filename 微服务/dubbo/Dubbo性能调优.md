# Dubbo 性能调优

##  常用的性能调优参数



| 参数名     | 作用范围 | 默认值    | 说明                                                         | 备注                        |
| ---------- | -------- | --------- | ------------------------------------------------------------ | --------------------------- |
| threads    | provider | 200       | 业务处理线程大小                                             |                             |
| iothreads  | provider | cpu个数+1 | io线程池大小                                                 |                             |
| queues     | provider | 0         | 线程池队列大小,当线程池满的时候, 排队等待执行的队列大小, 建议不要设置，当线程池满时,应该立即失败,重试其他服务提供机器,而不是排队,除非有特殊的要求 |                             |
| coeections | consumer | 0         | 对每个提供者的最大连接数,rmi、http、hessian等短连接协议表示限制连接数, Dubbo 等长连接协议表示建立的长连接个数 | Dubbo协议默认共享一个长连接 |
| actives    | consumer | 0         | 每个服务消费者每个服务每个方法最大并发调用数                 | 0 表示不限制                |
| accepts    | provider | 0         | 服务提供方最大可接受连接数                                   | 0 表示不限制                |
| executes   | provider | 0         | 服务提供者每服务每方法最大可并行执行请求数                   | 0 表示不限制                |

​	

## 每个参数的作用

![](http://files.luyanan.com//img/20191203143315.png)

1. 当concumer 发起一个请求时, 首先经过`active limit(参数actives)` 进行方法级别的限制, 其实现方式为CHM 中存放计数器(`AtomicInteger`), 请求时加1, 请求完成(包括异常)减1, 如果超过 `actives` 则等待有其他请求完后重试或者超时后失败; 
2. 从多个连接（`connections` ） 中选择一个连接发送数据, 对于默认的netty实现来说, 由于可以复用连接, 默认一个连接就可以, 不过如果你在压测, 且只有一个consumer、一个provider ,此时适当的加大 connections 却很少能够增强网络传输能力. 但是线上业务由于有多个 consumer多个provider , 因此不建议增加 connections参数. 
3. 连接到达provider时(如dubbo初次连接),首先会判断总连接是否超限(acceps),超过限制连接将被拒绝. 
4. 连接成功后, 具体的请求交给 `io thread`处理, `io threads` 虽然是处理数据的读写, 但io部分为异步, 更多的消耗的是cpu, 因此`iothreads` 默认cpu个数+1 是比较合理的设置, 不建议调整此参数. 
5. 数据读取并反序列化后，交给业务线程池处理,默认情况下线程池为 fixed, 且排队队列为0(queues),这种情况下,最大并发等于业务线程池大小(threads), 如果希望有请求的堆积能力, 可以调整queues 参数, 如果希望快速失败由其他节点处理(官方推荐方式), 则不修改queues, 只调整 threads.
6. execute limit （参数 executes）是方法级别的并发限制, 原理和 activies 类似,只是少了等待的过程, 受限制后立即失败. 

