{"root":{"data":{"id":"ce8ed4bdaac9","created":1593496330,"text":"设计模式","hyperlink":"https://luyanan.com/article/info/19487630063744","hyperlinkTitle":"设计模式"},"children":[{"data":{"id":"c43mv61pepk0","created":1594454266608,"text":"简介","expandState":"collapse","layout":null},"children":[{"data":{"id":"c3u7d1oj0b40","created":1593496490290,"text":"简介","expandState":"expand","layout":null},"children":[{"data":{"id":"c3u7d79eyig0","created":1593496502437,"text":"设计模式是一套被反复使用,多数人晓得经过分类编写,代码设计经验的总结,使用设计模式为了重用代码,让代码更加容易被理解,保证代码的可靠性. ","layout":null},"children":[]}]},{"data":{"id":"c3u7e0s82s00","created":1593496566701,"text":"设计原则","layout":null},"children":[{"data":{"id":"c3u7e8x9swo0","created":1593496584421,"text":"对接口编程而不是对实现编程","layout":null},"children":[]},{"data":{"id":"c3u7egxjqkw0","created":1593496601852,"text":"优先使用对象组合而不是继承","layout":null},"children":[]}]},{"data":{"id":"c3u7elt57a00","created":1593496612469,"text":"六大原则","layout":null},"children":[{"data":{"id":"c43mqnpoysg0","created":1594453913243,"text":"开闭原则","layout":null},"children":[{"data":{"id":"c43mrxmf6e00","created":1594454013178,"text":"开闭原则的意思是:对扩展开放,对修改关闭.在程序需要进行拓展的时候,不能去修改原有的代码,实现一个热插拔的效果.简言之,是为了使程序的扩展性好,易与维护和升级.想达到这样的效果,我们就需要使用接口和抽象类","layout":null},"children":[]}]},{"data":{"id":"c43mqq4gquo0","created":1594453918490,"text":"分支主题","resource":[],"layout":null},"children":[{"data":{"id":"c43ms05gk4o0","created":1594454018682,"text":"里氏代换原则是面向对象设计的基本原则之一.里氏原则中说,任何基类可以出现的地方,子类一定可以出现.LSP 是继承复用的基石,只有当派生类可以替换掉基类,且软件单位的功能不受到影响时,基类才能真正被复用,而派生类也能够在基类的基础上增加新的行为.里氏代换原则是对开闭原则的补充.实现开闭原则的关键步骤就是抽象化,而基类与子类的继承关系就是抽象化的具体实现,所以里氏代换原则是对实现抽象化的具体步骤的规范","layout":null},"children":[]}]},{"data":{"id":"c43mt1rgbvc0","created":1594454100552,"text":"依赖倒置原则","layout":null},"children":[{"data":{"id":"c43mubtk6i80","created":1594454200812,"text":"这个原则是开闭原则的基础,具体内容:针对接口编程,依赖与抽象而不依赖与具体","layout":null},"children":[]}]},{"data":{"id":"c43mt4prti80","created":1594454106981,"text":"接口隔离原则","layout":null},"children":[{"data":{"id":"c43mudt8ic80","created":1594454205146,"text":"这个原则的意思是:使用多个隔离的接口,比使用单个接口要好.它还有另外一个意思是:降低类之间的耦合度.由此可见,其实设计模式就是从大型软件架构出发,便于维护和升级的软件设计思想,它强调降低依赖,降低耦合","layout":null},"children":[]}]},{"data":{"id":"c43mt95liw00","created":1594454116645,"text":"迪米特原则,又称最少知道原则","layout":null},"children":[{"data":{"id":"c43mufqac0g0","created":1594454209321,"text":"最少知道原则是指: 一个实体应当尽量减少与其他实体之间发生相互作用,使得系统功能模块相对独立","layout":null},"children":[]}]},{"data":{"id":"c43mtcphc9c0","created":1594454124378,"text":"合成复用原则","layout":null},"children":[{"data":{"id":"c43mumxrhw00","created":1594454225011,"text":"合成复用原则是指:尽量使用合成/聚合的方式,而不是使用继承","layout":null},"children":[]}]},{"data":{"id":"c43mtg7u5xc0","created":1594454132018,"text":"单一职责原则","layout":null},"children":[{"data":{"id":"c43muoprt7c0","created":1594454228881,"text":"单一职责原则是指不要存在多于一个导致类变更的原因.假设我们有一个Class负责两个职责,一旦发生需求变更,修改其中一个职责的逻辑代码,有可能会导致另一个职责的功能发生故障,这样一来,这个Class存在两个导致类变更的原因 。  如何解决这个问题呢?我们就要給这两个职责分别以两个Class实现进行解耦.后期需求变更维护互不影响.这样的设计,可以降低类的复杂度,提高类的可读性,提高系统的可维护性,降低变更引起的风险.","layout":null},"children":[]}]}]},{"data":{"id":"c43musc7khs0","created":1594454236768,"text":"类型","layout":null},"children":[{"data":{"id":"c43mvjj0vls0","created":1594454295953,"text":"创建型模式","layout":null},"children":[{"data":{"id":"c43mvlcng1s0","created":1594454299921,"text":"描述 ","layout":null},"children":[{"data":{"id":"c43mvqkfbs00","created":1594454311275,"text":"这些设计模式提供了一种在创建对象的同时隐藏逻辑的方法,而不是使用new 运算符直接实例化对象.这使得程序在判断针对某个给定实例需要创建那些对象时更加灵活","layout":null},"children":[]}]},{"data":{"id":"c43mvvqxci80","created":1594454322552,"text":"包含","layout":null},"children":[{"data":{"id":"c43mvx1drz40","created":1594454325361,"text":"工厂模式(Factory Pattren)","layout":null},"children":[]},{"data":{"id":"c43mw7sm1i80","created":1594454348776,"text":"抽象工厂模式(Abstract Factory Pattren)","layout":null},"children":[]},{"data":{"id":"c43mwihvzx40","created":1594454372072,"text":"单例模式(Singleton Pattren)","layout":null},"children":[]},{"data":{"id":"c43mwtuz1r40","created":1594454396808,"text":"建造者模式(Builder Pattren)","layout":null},"children":[]},{"data":{"id":"c43mwz5ito80","created":1594454408330,"text":"原型模式(Prototype Pattren)","layout":null},"children":[]}]}]},{"data":{"id":"c43mx50e9i80","created":1594454421080,"text":"结构性模式","layout":null},"children":[{"data":{"id":"c43mx7pzar40","created":1594454426981,"text":"描述","layout":null},"children":[{"data":{"id":"c43mx8j0jwo0","created":1594454428736,"text":"这些设计模式关注类和对象的组合,继承的概念被用来组合接口和定义组合对象获取新功能的方式","layout":null},"children":[]}]},{"data":{"id":"c43mxlmarrk0","created":1594454457233,"text":"包含","layout":null},"children":[{"data":{"id":"c43mxmvtdb40","created":1594454459985,"text":"适配器模式(Adapter Pattren)","layout":null},"children":[]},{"data":{"id":"c43mxt09p880","created":1594454473315,"text":"桥接模式(Bridge Pattren)","layout":null},"children":[]},{"data":{"id":"c43my0jc3xk0","created":1594454489706,"text":"过滤器模式(Filter Pattren)","layout":null},"children":[]},{"data":{"id":"c43my51mxg80","created":1594454499519,"text":"组合模式(Composite Pattren)","layout":null},"children":[]},{"data":{"id":"c43myb1oyr40","created":1594454512584,"text":"装饰器模式(Decorator Pattren)","layout":null},"children":[]},{"data":{"id":"c43n2skip9c0","created":1594454864184,"text":"外观模式(Facade Pattren)","layout":null},"children":[]},{"data":{"id":"c43n31glwe00","created":1594454883538,"text":"享元模式(Flyweight Pattren)","layout":null},"children":[]},{"data":{"id":"c43n3g1fhk00","created":1594454915272,"text":"代理模式(Proxy Pattren)","layout":null},"children":[]}]}]},{"data":{"id":"c43n3m1ndr40","created":1594454928346,"text":"行为型模式","layout":null},"children":[{"data":{"id":"c43n3qnktk80","created":1594454938379,"text":"描述","layout":null},"children":[{"data":{"id":"c43n3s6plrc0","created":1594454941713,"text":"这些设计模式特别关注对象之间的通信","layout":null},"children":[]}]},{"data":{"id":"c43n4jeajtc0","created":1594455000945,"text":"包含","layout":null},"children":[{"data":{"id":"c43n4kl21ls0","created":1594455003530,"text":"责任链模式(Chain of Responblity Pattren)","layout":null},"children":[]},{"data":{"id":"c43n4ubb7uw0","created":1594455024709,"text":"命令模式(Command Pattren)","layout":null},"children":[]},{"data":{"id":"c43n529cba80","created":1594455042004,"text":"解释器模式(Interpreter Pattren)","layout":null},"children":[]},{"data":{"id":"c43n57zui740","created":1594455054492,"text":"迭代器模式(Interator Pattren)","layout":null},"children":[]},{"data":{"id":"c43n5dwqrs00","created":1594455067364,"text":"中介者模式(Mediator Pattren)","layout":null},"children":[]},{"data":{"id":"c43n6rsm4dk0","created":1594455175953,"text":"备忘录模式(Memento Pattren)"},"children":[]},{"data":{"id":"c43n6zk7whk0","created":1594455192860,"text":"观察者模式(Observer Pattren)"},"children":[]},{"data":{"id":"c43n76i50yg0","created":1594455207972,"text":"状态模式(State Pattren)"},"children":[]},{"data":{"id":"c43n7ab2zqo0","created":1594455216252,"text":"空对象模式(Null Object Pattren)"},"children":[]},{"data":{"id":"c43n7frgoi00","created":1594455228126,"text":"策略模式(Strategy Pattren)"},"children":[]},{"data":{"id":"c43n7qzy6js0","created":1594455252584,"text":"模板模式(Template Pattren)"},"children":[]},{"data":{"id":"c43n7yjznjc0","created":1594455269033,"text":"访问者模式(Visitor Pattren)"},"children":[]}]}]}]}]},{"data":{"id":"c43nwqbhc5k0","created":1594457210209,"text":"简单工厂模式","note":"4.1 抽象角色\n\n    package com.formula.design.factory;\n    \n    /**\n     * @author:luyanan\n     * @email:luyanan0718@163.com\n     * @date 2019/1/7\n     * @introduce\n     **/\n    public interface Fruit {\n    \n    \n        /**\n         * 采集方法\n         */\n        void collect();\n    \n    }\n    \n    \n\n4.2 具体产品(Concrete Product)角色 \n\n    package com.formula.design.factory;\n    \n    /**\n     * @author:luyanan\n     * @email:luyanan0718@163.com\n     * @date 2019/1/7\n     * @introduce 苹果\n     **/\n    public class Apple implements Fruit {\n        @Override\n        public void collect() {\n            System.out.println(\"苹果采集........\");\n        }\n    }\n    \n\n    package com.formula.design.factory;\n    \n    /**\n     * @author:luyanan\n     * @email:luyanan0718@163.com\n     * @date 2019/1/7\n     * @introduce 香蕉\n     **/\n    public class Banana implements Fruit {\n        @Override\n        public void collect() {\n            System.out.println(\"香蕉的采集.......\");\n        }\n    }\n    \n\n    package com.formula.design.factory;\n    \n    /**\n     * @author:luyanan\n     * @email:luyanan0718@163.com\n     * @date 2019/1/7\n     * @introduce 橘子\n     **/\n    public class Orange implements Fruit {\n        @Override\n        public void collect() {\n            System.out.println(\"橘子的采集.........\");\n        }\n    }\n    \n\n4.3 工厂(Creator) 角色\n\n    package com.formula.design.factory;\n    \n    /**\n     * @author:luyanan\n     * @email:luyanan0718@163.com\n     * @date 2019/1/7\n     * @introduce\n     **/\n    public class FruitFactory {\n    \n        // 苹果\n        public static final int apple = 1;\n        // 香蕉\n        public static final int banana = 2;\n        // 橘子\n        public static final int orange = 3;\n    \n        /**\n         * 获取实现类\n         *\n         * @param type\n         * @return\n         */\n        public static Fruit getFruit(int type) {\n            switch (type) {\n                case apple:\n                    return new Apple();\n                case banana:\n                    return new Banana();\n                case orange:\n                default:\n                    return new Orange();\n            }\n        }\n    \n    }\n    \n\n4.4  主方法\n\n    package com.formula.design.factory;\n    \n    /**\n     * @author:luyanan\n     * @email:luyanan0718@163.com\n     * @date 2019/1/7\n     * @introduce\n     **/\n    public class MainClass {\n        public static void main(String[] args) {\n            // 获取苹果的实例\n            Fruit apple = FruitFactory.getFruit(FruitFactory.apple);\n            apple.collect();\n            // 获取香蕉的实例\n            Fruit bannan = FruitFactory.getFruit(FruitFactory.banana);\n            bannan.collect();\n            // 获取橘子的实例\n            Fruit orange = FruitFactory.getFruit(FruitFactory.orange);\n            orange.collect();\n        }\n    }\n    \n\n结果\n","expandState":"collapse"},"children":[{"data":{"id":"c43nwv7zmmg0","created":1594457220881,"text":"概念"},"children":[{"data":{"id":"c43nwwm0biw0","created":1594457223906,"text":"通过专门定义一个类, 来负责创建其他类的实例, 被创建的实例通常拥有共同的父类"},"children":[]}]},{"data":{"id":"c43nxf1np480","created":1594457264034,"text":"角色与职责","expandState":"expand"},"children":[{"data":{"id":"c43nxiqrw7c0","created":1594457272083,"text":"工厂角色"},"children":[{"data":{"id":"c43nxkcfnvs0","created":1594457275570,"text":"工厂模式的核心,负责实现所创建的所有实例的内部逻辑,工厂可以被外界直接调用,创建所需要的产品对象"},"children":[]}]},{"data":{"id":"c43ny4tczy80","created":1594457320129,"text":"抽象角色"},"children":[{"data":{"id":"c43nyy0sqh40","created":1594457383705,"text":"工厂模式所创建的所有对象的父类,负责描述所有实例所共有的公共接口"},"children":[]}]},{"data":{"id":"c43nz77tzk00","created":1594457403722,"text":"具体产品"},"children":[{"data":{"id":"c43nz8mpqh40","created":1594457406798,"text":"工厂模式所创建的具体实例对象"},"children":[]}]}]},{"data":{"id":"c43nzg1i3iw0","created":1594457422930,"text":"优缺点"},"children":[{"data":{"id":"c43nzk126kg0","created":1594457431610,"text":"优点"},"children":[{"data":{"id":"c43nzlirqfc0","created":1594457434858,"text":"能够根据外界给定的信息,决定究竟应该创建哪个具体类的对象,用户无需了解这些对象如何被创建以及如何组织的"},"children":[]}]},{"data":{"id":"c43o0izy57c0","created":1594457507730,"text":"缺点"},"children":[{"data":{"id":"c43o0keilmo0","created":1594457510788,"text":"工厂类集合了所有实例的创建逻辑,所以高内聚方面做得不好,而且当系统中的具体产品类不断增多的时候,工厂类也要做出相应的修改,扩展性不是很好. "},"children":[]}]}]}]},{"data":{"id":"c43o4k3sshs0","created":1594457823597,"text":"工厂方式模式"},"children":[{"data":{"id":"c43o4lny6xs0","created":1594457826992,"text":"概念"},"children":[{"data":{"id":"c43o4n6c6vc0","created":1594457830281,"text":"定义一个创建产品对象的工厂接口,将实际创建产品推迟到子类中,核心工厂类不负责创建,这样核心类称为一个抽象工厂,仅负责具体子工厂类必须实现的接口,这样进一步抽象的好处使得工厂方式模板可以使系统在不修改具体工厂角色的情况下引进新的产品"},"children":[]}]},{"data":{"id":"c43o67c42tc0","created":1594457952530,"text":"角色和职责"},"children":[{"data":{"id":"c43o68y8wxc0","created":1594457956045,"text":"抽象工厂角色"},"children":[{"data":{"id":"c43o6bg8p740","created":1594457961486,"text":"工厂方式模式的核心,任何工厂类都必须实现这个接口"},"children":[]}]},{"data":{"id":"c43o6jmt4e00","created":1594457979298,"text":"具体工厂角色"},"children":[{"data":{"id":"c43o6myjj600","created":1594457986538,"text":"具体工厂类是抽象工厂类的一个实现,负责实例化产品对象"},"children":[]}]},{"data":{"id":"c43oichqx5s0","created":1594458904124,"text":"抽象产品角色"},"children":[{"data":{"id":"c43oig70hns0","created":1594458912182,"text":"工厂方法模式所创建的所有对象的父类,负责描述所有产品所共有的公共接口"},"children":[]}]},{"data":{"id":"c43ojhf7lyg0","created":1594458993219,"text":"具体产品角色"},"children":[{"data":{"id":"c43ojj6dm880","created":1594458997038,"text":"工厂方式模式所创建的具体对象"},"children":[]}]}]},{"data":{"id":"c43ojr94vz40","created":1594459014619,"text":"应用场景"},"children":[{"data":{"id":"c43ojsm3tgw0","created":1594459017580,"text":"一个类不知道它所需要的对象的类,在工厂方式模式中, 客户端不需要知道具体产品类的类名, 只需要所对应的工厂即可. 具体的产品类由具体的工厂创建. "},"children":[]},{"data":{"id":"c43p8tz31xk0","created":1594460979646,"text":"一个类通过其子类来制定创建哪个对象,在工厂方法模板中,对于抽象工厂类,只需要提供一个创建产品的接口,而由子类来确定具体要创建的对象"},"children":[]}]},{"data":{"id":"c43p9t7v34o0","created":1594461056364,"text":"优点"},"children":[{"data":{"id":"c43p9ufx3nc0","created":1594461059028,"text":"在工厂方式模式中,工厂方法"},"children":[]}]}]},{"data":{"id":"c43n9xu7he80","created":1594455424203,"text":"spring中常用的设计模式"},"children":[{"data":{"id":"c43na5h95600","created":1594455440834,"text":"工厂模式"},"children":[{"data":{"id":"c43na9io96w0","created":1594455449627,"text":"BeanFactory,Calender"},"children":[]}]},{"data":{"id":"c43nassgtr40","created":1594455491578,"text":"单例模式"},"children":[{"data":{"id":"c43nayxx6vk0","created":1594455504968,"text":"ApplicationContext,Calender"},"children":[]}]},{"data":{"id":"c43nb29xyeo0","created":1594455512225,"text":"原型模式"},"children":[{"data":{"id":"c43nb3wtdh40","created":1594455515785,"text":"ArrayList,PrototypeBean"},"children":[]}]},{"data":{"id":"c43nbynkf3s0","created":1594455582706,"text":"代理模式"},"children":[{"data":{"id":"c43nc1fqeu80","created":1594455588763,"text":"ProxyFactoryBean,JDKDynamicAopFactory,CglibAopFactory"},"children":[]}]},{"data":{"id":"c43nc23rtww0","created":1594455590217,"text":"委派模式"},"children":[{"data":{"id":"c43nc5afdv40","created":1594455597149,"text":"DispatcherServlet,BeanDefinitionParserDelegate"},"children":[]}]},{"data":{"id":"c43nvud4yww0","created":1594457140652,"text":"策略模式"},"children":[{"data":{"id":"c43nvxq2pgw0","created":1594457147964,"text":"InstantiationStrategy"},"children":[]}]},{"data":{"id":"c43nvzsecqg0","created":1594457152458,"text":"模板模式"},"children":[{"data":{"id":"c43nw23o6qg0","created":1594457157494,"text":"jdbcTemplate,HttpServlet"},"children":[]}]},{"data":{"id":"c43nw5a6kds0","created":1594457164418,"text":"适配器模式"},"children":[{"data":{"id":"c43nw8mrluo0","created":1594457171709,"text":"AdvisorAdapter,HandlerAdapter"},"children":[]}]},{"data":{"id":"c43nwamp8e00","created":1594457176059,"text":"装饰器模式"},"children":[{"data":{"id":"c43nwe0c7k80","created":1594457183414,"text":"BufferedReader,InputStream,OutputStream,HttpHeadResponseDecorator"},"children":[]}]},{"data":{"id":"c43nwh1aic00","created":1594457190002,"text":"观察者模式 "},"children":[{"data":{"id":"c43nwnczv3s0","created":1594457203770,"text":"ContextLoaderListener"},"children":[]}]}]}]},"template":"right","theme":"classic","version":"1.4.43"}