# redis实战之数据一致性

##  1 缓存使用场景

针对读少写多的高并发场景, 我们可以使用缓存来提升查询速度. 

当我们使用reids 作为缓存的时候, 一般流程是这样的:

1. 如果数据在redis 缓存中, 应用就可以直接从redis 拿到数据, 不用访问数据库. 

    ![image-20200403085340776](http://files.luyanan.com//img/20200403100037.png)	

2. 如果redis 里面没有，先到数据库查询, 然后写入到redis,再返回给应用. 

    ![image-20200403090003337](http://files.luyanan.com//img/20200403100032.png)

## 2. 数据一致性的问题

因为这些数据是很少修改的, 所以在绝大部分的情况下可以命中缓存. 但是, 一旦被缓存的数据发生变化的时候, 我们既要操作数据库的数据, 也要操作redis 的数据, 所以问题来了, 现在我们有两种选择:

1. 先操作reids 的数据再操作数据库的数据
2. 先操作数据库的数据再操作redis 的数据. 

到底选哪一种呢? 

首先需要明确的是, 不管选择哪一种方案, 我们肯定是希望两个操作要么都成功, 要么都不成功, 要不然就会发生redis 跟数据库的数据不一致的问题. 

但是, redis 的数据跟数据库的数据是不可能通过事务达到统一的, 我们只能根据相应的场景和所需要付出的代码来采取一些措施来降低数据不一致的问题出现的概率, 在数据一致性和性能之间取到一个权衡. 

对于数据库的实时性一致性要求不是特别高的场合, 比如T+1的报表, 可以采用定时任务查询数据库数据同步到redis 的方案. 

由于我们是以数据库的数据为准的, 所以给缓存设置一个过期时间, 是保证最终一致性的解决方案. 



## 3. 方案选择

### 3.1 Redis: 删除还是更新

这里我们先要补充一点, 当存储的数据发生变化,redis 的数据也要更新的时候, 我们有两种方案, 一种就是直接更新, 调用`set`, 还有一种是直接删除缓存, 让应用在下次查询的时候重新写入. 

这两种方案怎么选择呢? 这里我们主要考虑更新缓存的代价. 

更新缓存之前, 是不是要经过其他表的查询, 接口调用, 计算才能得到最新的数据，而不是直接从数据库拿到的值。如果是的话,建议直接删除缓存, 这种方案更加的简单，而且避免了数据库的数据和缓存不一致的情况. 在一般情况下, 我们也推荐使用删除方案. 

这一点明确后, 现在我们就剩一个问题:

- 到底是先更新数据库,再删除缓存
- 还是先删除缓存, 再更新数据库呢? 

我们先看第一种方案

### 3.2 先更新数据库, 再删除缓存

正常情况： 

- 更新数据库, 成功
- 删除缓存.成功. 

异常情况： 

1. 更新数据库失败, 程序捕获异常, 不会走到下一步, 所以数据不会出现不一致.
2. 更新数据库成功,删除缓存失败, 数据库是新数据,缓存是旧数据, 发生了数据不一致的情况. 

这种问题怎么解决呢? 我们可以提供一个重试的机制. 

比如: 如果删除缓存失败, 我们捕获这个异常, 把需要删除的key发送到消息队列,然后自己创建一个消费者消费, 尝试再次删除这个key. 

这种方式有个缺点, 会对业务代码造成入侵. 



所以我们就有了第二种方案(异步更新缓存)

因为更新数据库会往`binglog` 写入日志, 所以我们可以通过一个服务来监听`binlog` 的变化(例如阿里的`canal`), 然后在客户端完成删除`key` 的操作, 如果删除失败的话再发送到消息队列. 

总之, 对于后删除缓存失败的情况, 我们的做法是不断的重试删除, 直到成功. 

无论是重试还是异步删除, 都是最终一致性的思想. 



###   3.3 先删除缓存, 再更新数据库

正常情况: 

删除缓存, 成功. 

更新数据库, 成功. 

异常情况： 

1. 删除异常, 程序捕获异常,不会走到下一步, 所以数据不会出现不一致的情况. 
2. 删除缓存成功, 更新数据库失败, 因为以数据库的数据为准, 所以不存在数据不一致的情况., 

看起来好像没有什么问题,但是如果有程序并发操作的情况. 

- 线程A需要更新数据, 首先删除了redis缓存
- 线程B 查询数据, 发现缓存不存在, 到数据库查询旧值, 写入到redis, 返回. 
- 线程A 更新了数据库. 

这个时候, redis 是旧的值, 数据库是新的值, 发生了数据不一致的情况. 

那问题就变成了: 能不能对同一条数据点访问串行化呢? 代码肯定是保证不了, 因为有多个线程, 即使做了任务队列也可能有多个服务实例. 数据库也保证不了, 因为会有多个数据库的连接。 只有一个数据库只提供一个连接的情况下, 才能保证读写的操作是串行的, 或者我们把所有的读写请求放到一个内存队列中, 但是这种情况 吞吐量太低了. 

所以我们就有一种延时双删的策略, 在写入数据后, 再删除一次缓存. 

A线程: 

- 删除缓存
- 更新数据库
- 休眠500ms(这个时间根据读取数据库的耗时而定)
- 再次删除缓存



**伪代码:**

```java
public void write(String key,Object data){
 redis.delKey(key);
 db.updateData(data);
 Thread.sleep(500);
 redis.delKey(key);
}
```

