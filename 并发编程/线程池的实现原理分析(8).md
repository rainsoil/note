# 8. 线程池的实现原理分析

###  什么是线程池

在java中,如果每个请求到达就创建一个线程,创建和销毁线程花费的时间和消耗的系统资源都相当大,甚至可能要比在处理实际的用户请求的时间和资源都多的多.

如果在一个jvm里创建了太多的线程,可能会使得系统由于过度消耗内存或"切换过度"而导致系统资源不足

为了解决这个问题,就由了线程池的概念,线程池的核心逻辑是提前创建好若干个线程放在一个容器中. 如果由任务需要处理,则将任务直接分配给线程池中的线程来执行就行,任务处理完了之后这个线程不会被销毁,而是等待后续分配任务,同时线程池通过重复管理线程可以避免大量线程增加开销.

### 线程池的优势

合理的使用线程池,可以带来一些好处:

1. 降低创建线程和销毁线程的性能开销
2. 提高响应速度,当由新任务需要执行是不需要等待线程创建就可以立马执行
3. 合理的设置线程池的大小可以避免因为线程数超过硬件资源瓶颈带来的问题

##  Java 中提供的线程池API

### 线程池的使用

要了解一个技术,我们仍然是从使用开始,JDK为我们提供了几种不同的线程池来实现,我们先来通过一个简单的案例来引入线程池的基本使用

在java中怎么创建线程池呢? 下面这段代码演示了创建三个固定线程数的线程池

```java
public class ThreadPoolDemo implements Runnable {


    @Override
    public void run() {

        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }


    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ThreadPoolDemo());
        }
        executorService.shutdown();
    }

}

```

### java 中提供了线程池API

为了方便大家对于线程池的使用,在Executors 里面提供了几个线程池的工厂方法,这样,很多新手就不需要了解太多关于 ThreadPoolExecutor 的知识了.他们只需要直接使用 Executors的工厂方法.就可以使用线程池了

- newFixedThreadPool: 该方法返回一个固定数量的线程池,线程数保持不变,当有一个任务提交的时候,若线程池中空闲,则立即执行,若没有,则会被暂缓在一个任务队列中,等待有空闲的线程去执行.
- newSingleThreadExecutor: 创建一个线程的线程池,若空闲则执行,若没有空闲线程则暂缓在任务队列中
- newCachedThreadPool:返回一个可根据实际情况调整线程个数的线程池,不限制最大线程的数量,
- newScheduledThreadPool: 创建一个可以指定线程的数量的线程池,但是这个线程池还带有延迟和周期性的执行任务的功能,类似定时器

#### ThreadPoolExector

上面提到的四种线程池的构建,都是基于ThreadPoolExecutor 来构建的,接下来看了解一下 ThreadPoolExecutor 有哪些构造参数

```java
  public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
    
```

ThreadPoolExecutor  有多个重载的构造方法,我们可以基于它最完整的构造方法来分析.先来解释一下每个参数的作用,稍后我们再来分析源码的过程中再来详细了解参数的意义.

```java
  public ThreadPoolExecutor(int corePoolSize,  // 核心线程数量
                              int maximumPoolSize,// 最大线程数量
                              long keepAliveTime,// 超时时间,超过核心线程之外的线程空余存活时间
                              TimeUnit unit,// 存活时间单位
                              BlockingQueue<Runnable> workQueue, // 保存执行任务的队列
                              ThreadFactory threadFactory, // 创建新线程使用的工厂
                              RejectedExecutionHandler handler// 当任务无法执行的时候处理方式
    )
```

线程池初始化的时候是没有创建线程的,线程池里面的线程的初始化跟其他线程一样,但是在完成任务后,该线程不会自行销毁,而是以挂起的方式返回到线程池,直到应用程序再次向线程池发起请求时,线程池里挂起的线程就会再度激活执行任务,这样 即节省了建立线程所造成的性能损耗,也可以让多个任务反复重用同一个线程, 从而在应用程序生存期内节省大量开销.

#### newFixedThreadPool

```
  public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

newFixedThreadPool的核心线程数和最大线程池都是指定值,也就是说当前线程中的线程数量超过核心线程数后,任务都是会放在阻塞队列,另外 keepAliveTime 为0，也就是说超过核心线程数量以外的线程空余存活时间为0,而这里选用的阻塞队列为LinkedBlockingQueue ,使用的是默认的容量Integer.MAX_VALUE,相当于没有上限.

这个线程池执行任务的流程如下:

1. 线程数少于核心线程数,也就是设置的线程数时,新建线程执行任务
2. 线程数等于核心线程数时,将任务加入阻塞队列
3. 由于队列容量非常大,可以一直添加
4. 执行任务的线程反复去队列中取任务执行

用途： newFixedThreadPool 用于负载比较大的服务器,为了资源的合理利用,需要限制当前线程数量

#### newCachedThreadPool

```java
 public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```



newCachedThreadPool 创建一个可缓存的线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则新建线程. 并且没有核心线程,非核心线程无上限,但是每个空闲线程的时间只有60秒,超过后就会被回收,

它的执行流程如下:

1. 没有核心线程,直接向SynchronousQueue 中添加任务
2. 如果有空闲线程,就去取出任务执行,如果没有空闲线程,就新建一个
3. 执行完任务的线程有60秒的生存时间,如果这个时间内可以接到新的任务,就可以继续或者,否则就会被回收.

#### newSingleThreadExecutor

创建一个单线程化的线程池,它只会用唯一的工作线程来执行,保证所有任务按照指定的顺序(FIFO,LIFO 优先级)执行

## 线程池的实现原理分析

线程池的基本使用我们都清楚了,接下来我们了解一下线程池的实现原理,ThreadPoolExecutor 是线程池的核心,提供了线程池的实现.

ScheduledThreadPoolExecutor 继承了ThreadPoolExecutor, 并另外提供了一些调度方法以及支持定时和周期任务, Executors 是工具类, 主要用来创建线程池对象.

我们把一个任务提交给线程池去处理,线程池的处理过程是怎么样的呢? 首先直接来看看定义

####  线程池原理分析(FixedThreadPool)

![](http://files.luyanan.com//img/20190817145515.png)

#### 源码分析

基于源码入口进行分析,先看execute 方法

```java
 public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        // 1.  当前池中线程比核心数少,新建一个线程执行任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //  2. 核心池已满,但任务队列未满,添加到队列中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // 任务成功队列以后,再次检查是否需要添加新的线程,因为已存在的线程可能被销毁了
            if (!isRunning(recheck) && remove(command))
                //  如果线程池处于非运行状态,并且把当前任务从任务队列中移除成功,则拒绝该任务
                reject(command);
            // 如果之前的线程已经被销毁完了，新建一个线程
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
            // 3. 核心池已满, 队列已满,试着创建一个新的线程
        } else if (!addWorker(command, false))
            // 如果创建新线程失败了,说明线程池已经被关闭或者线程池完全满了,拒绝任务
            reject(command);
    }
    
```

#### ctl的作用

在线程池中,ctl 贯穿在整个线程池的生命周期中

```java
ctl：
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING,
0));
```

它是一个原子类,主要作用是用来保存线程数量和线程池状态的.我们来分析一下这段代码,其实很有意思,它用到了位运算.
一个int数值是32个bit位,这里采用高3位来保存运行状态,低29位来保存线程数量

我们来分析默认情况下,也就是 ctlOf(RUNNING, 0) 运行状态,调用了ctlOf(int rs, int wc) 方法,其中

> ```java
> private static int ctlOf(int rs, int wc) {    return rs | wc;}
> ```

其中  RUNNING = -1 << COUNT_BITS ； -1 左移29位,-1的二进制是 32个1(1111 1111 1111 1111 1111 1111 1111 1111 )

>  -1 的二进制计算方法
>
> 原码是 1000 ..001  高位1表示符号位
>
> 然后对原码取反,高位不变得到 1111...110
>
> 然后对反码进行+1, 也就是补码操作,最后得到 1111 .. 1111

那么 -1 << 左移29位,也就是[111] 表示  rs | wc . 二进制是111|000. 得到的结果仍然是111

那么同理的可得到其他的状态的bit 位表示

```java
   private static final int COUNT_BITS = Integer.SIZE - 3;  //  32 - 3
    private static final int CAPACITY = (1 << COUNT_BITS) - 1; // 将1的二进制右移29位,再减1 表示最大线程容量

    // runState is stored in the high-order bits
    // 运行状态保存在int值的高3位(所有数值左移29位)
    private static final int RUNNING = -1 << COUNT_BITS; // 接受新任务,并执行队列中的任务 
    private static final int SHUTDOWN = 0 << COUNT_BITS; // 不接受新任务,但是执行队列中的任务
    private static final int STOP = 1 << COUNT_BITS; // 不接受新任务,不执行队列中的任务,中断正在执行的任务
    private static final int TIDYING = 2 << COUNT_BITS; // 所有的任务都已经结束,线程数量为0,处于该状态的线程池即将调用 terminated() 方法
    private static final int TERMINATED = 3 << COUNT_BITS; // terminated 方法执行完成
    
```

状态变化

![](http://files.luyanan.com//img/20190817155008.png)

#### addWorker

如果工作线程数小于核心线程数的话,会调用addWorker ,顾名思义,其实就是创建一个工作线程.我们来看看源码的实现

源码其实只是做了两件事情,

1. 用循环CAS操作来将线程数加1

2. 新建一个线程并启动

   ````java
   private boolean addWorker(Runnable firstTask, boolean core) {
           // goto 语句,避免死循环
           retry:
           for (; ; ) {
               int c = ctl.get();
               int rs = runStateOf(c);
   
               // Check if queue empty only if necessary.
               // 如果线程处于非运行状态,并且rs 不等于SHUTDOWN 且firstTask 不等于null 且workQueue 队列为空,直接返回false(表示不可添加work状态)
               // 1. 线程池已经 shutdown ,还要添加任务,拒绝
               // 2. shutdown 状态不接受新任务,但是仍然会执行已经加入到队列任务的任务,所以当进入 shutdown 状态,而传进来的任务为空,
               // 并且任务队列不为空的时候,是允许添加新线程的,如果把这个条件取反,就表示不允许添加worker
   
               if (rs >= SHUTDOWN &&
                       !(rs == SHUTDOWN &&
                               firstTask == null &&
                               !workQueue.isEmpty()))
                   return false;
   
               // 自旋
               for (; ; ) {
                   // 获取worker 工作线程数
                   int wc = workerCountOf(c);
                   // 如果工作线程数大于默认容量大小或者大于核心线程数大小,则直接返回false 表示不能再添加worker
                   if (wc >= CAPACITY ||
                           wc >= (core ? corePoolSize : maximumPoolSize))
                       return false;
                   // 通过CAS 来增加工作线程数,如果CAS失败,则直接重试
                   if (compareAndIncrementWorkerCount(c))
                       break retry;
                   // 再次获取ctl的值
                   c = ctl.get();  // Re-read ctl
                   // 这里如果不相等,说明线程的状态发生了变化,继续重试
                   if (runStateOf(c) != rs)
                       continue retry;
                   // else CAS failed due to workerCount change; retry inner loop
               }
           }
   
           // 上面这段代码主要是对worker 数量做原子+1 操作,下面的逻辑才是正式构建一个worker
           // 工作线程是否启动的标示
           boolean workerStarted = false;
           // 工作线程是否已经添加成功的标识
           boolean workerAdded = false;
           Worker w = null;
           try {
               // 构建一个Worker ,
               w = new Worker(firstTask);
               // 从worker对象取出线程
               final Thread t = w.thread;
               if (t != null) {
                   final ReentrantLock mainLock = this.mainLock;
                   // 这里有个重入锁,避免并发问题
                   mainLock.lock();
                   try {
                       // Recheck while holding lock.
                       // Back out on ThreadFactory failure or if
                       // shut down before lock acquired.
                       int rs = runStateOf(ctl.get());
                       // 只有当线程池是正在运行状态(或是SHUTDOWN 且 firstTask 不为空),才能添加到workers 集合
                       if (rs < SHUTDOWN ||
                               (rs == SHUTDOWN && firstTask == null)) {
                           
                           if (t.isAlive()) // precheck that t is startable
                               throw new IllegalThreadStateException();
                           // 将新创建的worker添加到 workers 集合中
                           workers.add(w);
                           int s = workers.size();
                           // 如果集合中的工作线程大于最大线程数,这个最大线程表示线程池曾经出现过的足最大线程数
                           if (s > largestPoolSize)
                               // 更新线程池出现过的最大线程数
                               largestPoolSize = s;
                           // 表示工作线程创建成功了
                           workerAdded = true;
                       }
                   } finally {
                       mainLock.unlock();
                   }
                   // 如果worker 添加成功
                   if (workerAdded) {
                       // 启动线程
                       t.start();
                       workerStarted = true;
                   }
               }
           } finally {
               if (!workerStarted)
                   // 如果添加失败,就需要做一件事情,就是递减实际工作线程数
                   addWorkerFailed(w);
           }
           return workerStarted;
       }
       
   ````

   #### Worker 类说明

   我们发现addWorker 方法只是构造了一个Worker,并且把firstTask 封装到了worker中,它是做什么的呢?我们来看看?

   1.  每个worker 都是一个线程,同时里面包含了 一个firstTask,即初始化时要被首先执行的任务

   2. 最终执行的任务是runWorker方法

      Worker 类继承AQS,并实现了Runnable接口,注意其中的firstTask和thread 属性: 

      - firstTask: 用它来保存传入的任务
      - thread: 是在调用构造方法的时候通过ThreadFactory 来创建线程的,是用来处理任务的线程.

      在调用构造方法时，需要传入任务,这里通过getThreadFactory().newThread(this);来新建一个线程,newThread 反方法传入的参数是this, 因为Worker 本身继承了Runnable 接口,也就是一个线程,所以一个Worker 对象在启动的时候会调用 Worker类中的run方法

      Worker 继承了AQS, 使用AQS来实现独占锁的功能, 为什么不使用ReentrantLock 来实现呢? 可以看到tryAcquire方法,它是不允许重入的,而ReentrantLock 是允许重入的,lock方法一旦获取了独占锁,表示当前线程正在执行任务,那么它会有一下几个作用：

      1. 如果正在执行任务,则不应该中断线程
      2. 如果该线程限制不是独占锁状态，也就是空闲的状态,说明它没有在处理任务,这时可以对该线程进行中断,
      3. 线程池在执行shutdown 方法或者 tryTerminate 方法时会调用 interruptWorkers方法来中断空闲的线程,interruptWorkers 方法会使得tryLock 方法来判断线程池中的线程是否是空闲状态,
      4. 之所以设置为不可重入,是因为我们不希望任务在调用像setCorePoolSize 这样的线程池控制方法时重新获取锁,这样会中断正在运行的线程.

      ```java
      private final class Worker
                  extends AbstractQueuedSynchronizer
                  implements Runnable {
              /**
               * This class will never be serialized, but we provide a
               * serialVersionUID to suppress a javac warning.
               */
              private static final long serialVersionUID = 6138294804551838833L;
      
              /**
               * Thread this worker is running in.  Null if factory fails.
               */
              // 这才是真正执行task的线程,从构造函数得到是由 ThreadFactory 创建的
              final Thread thread;
              /**
               * Initial task to run.  Possibly null.
               */
              // 这是需要执行的task
              Runnable firstTask;
              /**
               * Per-thread task counter
               */
              // 完成的任务数,用于线程池统计
              volatile long completedTasks;
      
              /**
               * Creates with given first task and thread from ThreadFactory.
               *
               * @param firstTask the first task (null if none)
               */
              Worker(Runnable firstTask) {
                  // 初始状态 -1,防止在调用 runWorker(),也就是真正执行task 前中断thread 
                  setState(-1); // inhibit interrupts until runWorker
                  this.firstTask = firstTask;
                  this.thread = getThreadFactory().newThread(this);
              }
      
              /**
               * Delegates main run loop to outer runWorker
               */
              public void run() {
                  runWorker(this);
              }
      
              // Lock methods
              //
              // The value 0 represents the unlocked state.
              // The value 1 represents the locked state.
      
              protected boolean isHeldExclusively() {
                  return getState() != 0;
              }
      
              protected boolean tryAcquire(int unused) {
                  if (compareAndSetState(0, 1)) {
                      setExclusiveOwnerThread(Thread.currentThread());
                      return true;
                  }
                  return false;
              }
      
              protected boolean tryRelease(int unused) {
                  setExclusiveOwnerThread(null);
                  setState(0);
                  return true;
              }
      
              public void lock() {
                  acquire(1);
              }
      
              public boolean tryLock() {
                  return tryAcquire(1);
              }
      
              public void unlock() {
                  release(1);
              }
      
              public boolean isLocked() {
                  return isHeldExclusively();
              }
      
              void interruptIfStarted() {
                  Thread t;
                  if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                      try {
                          t.interrupt();
                      } catch (SecurityException ignore) {
                      }
                  }
              }
          }
      
      ```

      

#### **addWorkerFailed**

addWorker 中,如果添加Worker 并且启动线程失败,则会做失败后的处理,这个方法主要做两件事情

1. 如果worker 已经构建好,则从workers 集合中移除这个 worker
2. 原子递减核心线程数(因为在addWorker方法中先做了原子增加)
3. 尝试结束线程池

```java
 private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);
            decrementWorkerCount();
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }

```

#### runWorker 方法

前面已经了解过ThreadPoolExecutor 的核心方法 addWorker , 主要作用是增加工作线程,而Worker 简单理解其实就是一个线程,里面重写了run方法,这块是线程池中执行任务的真正逻辑.也就是runWorker 方法,这个方法主要做几件事情

1. 如果task 不为空,则执行task
2. 如果task为空,则通过getTask 再去取任务,并复制给task, 如果取到的Runnable 不为空,则执行该任务
3. 执行任务完毕后,通过while 循环继续getTask 取任务
4. 如果getTsk() 取到的任务依然是空,那么整个 runWorker()方法执行结束

```java
final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        // unlock 表示当前worker 线程允许被中断,因为new Worker 默认的state = 1, 此处是调用 Worker 类的tryRelease() 方法,将state 置为0
        // 而 interruptIfStarted() 中只有 state >=0 才被与允许调用中断
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            // 注意这个 while 循环,在这里实现了线程复用,如果task 不为空,则通过getTask 来取任务
            while (task != null || (task = getTask()) != null) {
                // 上锁,不是为了防止并发执行任务,为了再shutdown() 时不终止正在运行的worker
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                // 线程池为stop状态时不接受新任务,不执行已经加入队列中的任务,还中断正在执行的任务
                // 所以对于stop 状态线程是要中断线程的
                // Thread.interrupted() &&runStateAtLeast(ctl.get(), STOP)) 确保线程中断标识位为true 且是stop状态,接着清楚了中断标识
                // !wt.isInterrupted() 则要再一次检查保证线程需要设置中断标识位
                if ((runStateAtLeast(ctl.get(), STOP) ||
                        (Thread.interrupted() &&
                                runStateAtLeast(ctl.get(), STOP))) &&
                        !wt.isInterrupted())
                    wt.interrupt();
                try {
                    // 这里默认是没有实现的,在一些特定的场景中,我们可以自己继承 ThreadPoolExecutor 自己重写
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        // 执行任务中的方法
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x;
                        throw x;
                    } catch (Error x) {
                        thrown = x;
                        throw x;
                    } catch (Throwable x) {
                        thrown = x;
                        throw new Error(x);
                    } finally {
                        // 这里默认也是没有实现的
                        afterExecute(task, thrown);
                    }
                } finally {
                    // 置空任务(这样下次循环开始时,task 依然为null, 需要在通过getTask() 取)
                    task = null;
                    // 记录该worker 完成任务数量
                    w.completedTasks++;
                    //  解锁
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            // 1. 将入参worker 从数组workres 中移除
            // 2. 根据布尔值 allowCoreThreadTimeOut 来决定是否需要补充新的Worker  进数组 workers 
            processWorkerExit(w, completedAbruptly);
        }
    }
```

#### getTask()

worker 线程会从阻塞队列汇总获取需要执行的任务,这个方法不是简单的task 数据,我们来分析一下他的源码

>  你也许好奇是怎么判断线程有多久没有活动了,是不是以为线程池也会启动一个监控线程,专门监控哪个线程正在偷懒? 想太多,其实只是在线程从工作队列poll任务时,加上了超时时间限制,如果线程在keepValueTime的时间内poll不到新的任务,那么就认为这条线程没事做,可以干掉了,看看这个代码片段就知道了

```java
  private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        // 自旋
        for (; ; ) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            // 对线程池的判断,两种情况下会 workerCount -1,返回返回null
            // 1. 线程池状态为SHUTDOWN 且workQueue 为空(反应了 SHUTDOWN 状态的线程池还是要执行 workerQueue 中剩余的任务的)
            // 2. 线程池状态为stop(shutdownNow 会导致变成stop) (此时不需要考虑workerQueue 的情况)
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                // 返回null,则当前worker 线程会退出
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            // timed变量用于判断是否需要进行线程超时控制
            // allowCoreThreadTimeOut 默认是false,也就是核心线程 不允许进行超时
            // wc > corePoolSize  表示当前线程池中的线程数量大于核心线程数量
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            // 1. 线程数量超过了maximumPoolSize 可能是线程池在运行时被调用了 setMaximumPoolSize() 时被改变了大小,
            // 否则已经addWorker()成功不会超过 maximumPoolSize
            // 2. timed && timedOut 如果为trur,表示当前操作需要进行超时控制,并且上次从阻塞队列中获取任务发生了超时,其实就是体现了空闲线程的超时时间
            if ((wc > maximumPoolSize || (timed && timedOut))
                    && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                // 根据timed判断,如果为true,则通过阻塞队列poll 方法来进行超时控制,如果在keepAliveTime 时间内没有获取到任务,则返回 null
                // 否则通过task 方法阻塞式获取队列中的任务
                Runnable r = timed ?
                        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                        workQueue.take();
               // 如果拿到的任务不为空,则直接返回给worker 进行处理
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                // 如果获取任务时当前线程发生了中断,则设置timeOut 为false 并返回循环重试
                timedOut = false;
            }
        }
    }
```

这里最重要的地方是第二个if判断,目的是控制线程池的有效线程数量.由上文汇总的分析可以知道,在执行execute 方法时,如果当前线程池的数量超过了corePoolSize 且小于maximumPoolSize, 并且 workQueue 已满时,则可以增加工作线程,但是这时如果超时,没有获取到任务, 也就是 timedOut 为true 的情况, 说明workQueue 已经为空了,也就是说明了当前线程池中不需要那么多线程来执行任务了,可以把多余的 corePoolSize 数量的线程销毁掉,保持线程数量在corePoolSize 即可

什么时候会销毁呢? 当然是 runWorker 方法执行完之后,也就是 Worker 中的run方法完,由JVM自动回收.,

getTask() 方法返回null 时, 在runWorker 方法中会跳出 while 循环,然后会执行 processWorkerExit 方法.

#### processWorkerExit

runWorker 的 while 循环执行完以后,在finally 中会调用processWorkerExit ,来销毁工作线程.

到目前为止,我们已经从execute 方法中了解了worker 线程的创建到执行以及最后到销毁的全部过程，那么我们继续回到 execute方法, 我们只是分析完了 addWorker 这段逻辑.,继续来看后面的判断,

#### execute后续逻辑判断

如果核心线程已满,说明这个时候不能再创建核心线程了,于是走第二个判断,第二个判断逻辑比较简单,如果线程池处于运行状态并且任务队列没满,则将任务添加到队列中

第三个判断,核心线程数满了,队列也满了,那么这个时候创建新的线程也就是(非核心线程)

如果非核心线程数也达到了最大线程数量,则直接拒绝任务

```java
    //  2. 核心池已满,但任务队列未满,添加到队列中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // 任务成功队列以后,再次检查是否需要添加新的线程,因为已存在的线程可能被销毁了
            if (!isRunning(recheck) && remove(command))
                //  如果线程池处于非运行状态,并且把当前任务从任务队列中移除成功,则拒绝该任务
                reject(command);
                // 如果之前的线程已经被销毁完了，新建一个线程
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
            // 3. 核心池已满, 队列已满,试着创建一个新的线程
        } else if (!addWorker(command, false))
            // 如果创建新线程失败了,说明线程池已经被关闭或者线程池完全满了,拒绝任务
            reject(command);
    }
    
```

####  拒绝策略

1. AbortPolicy: 直接抛出异常,默认策略
2. CallerRunsPolicy: 用调用者所在的线程来执行任务
3. DiscardOldestPolicy: 丢弃阻塞队列中最靠前的任务,并执行当前任务
4. DiscardPolicy: 直接丢弃任务

当然也可以根据应用场景实现RejectedExecutionHandler 接口,自定义饱和策略,.如 记录日志或者持久化存储不能处理的任务



### 线程池的注意事项

分析完线程池以后,我们来了解一下线程池的注意事项

#### 阿里开发手册不建议线程池的构建使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。

用 Executors  是的用户不需要关心线程池的参数配置,意味着大家对于线程池的运行规则也会慢慢的忽略,这会导致一个问题,比如我们用 newFixdThreadPool 或者 singleThreadPool  允许的队列长度为Iinteger.MAX_VALUE, 如果使用不当会导致大量的请求堆积到队列中导致OOM的风险,而 newCachedThreadPool， 允许创建的线程数量为 INteger.MAX_VALUE, 也可能会导致大量的线程出现CPU 过高或者OOM的问题.

而如果我们通过 ThreadPoolExecutor 来构造线程池的话,我们势必要了解线程池构造中的每个参数的具体含义,使得开发者在配置参数的时候能够更加的谨慎,

#### 如何合理的分配线程池的大小

在遇到这类问题的时候,先冷静下来分析

1. 需要分析线程池执行的任务特性:CPU密集型还是IO密集型
2. 每个任务执行的平均时长大概是 多少? 这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系

如果是CPU密集型,主要是执行计算任务,响应时间很快,cpu一直运行,这种任务的cpu的利用率很高,那么线程数的配置应该根据CPU核心数来决定的, CPU核心数 - 最大同时执行的线程数, 加入CPU核心数为4,那么服务器最多能同时执行4个线程,过多的线程会导致上下文的切换反而导致效率降低,那么线程池的最大的线程数可以配置成CPU核心数+1

如果是IO密集型,主要是进行IO操作,执行IO操作的时间较长,这时COU处于空闲状态，导致COU的利用率不高,这种情况下可以增加线程池的大小. 这种情况下可以结合线程的等待时长来做判断,等待时间越高,那么线程数也相对越多,  一般可以配置 cpu核心数的2倍, 一个公式： 线程池设定的最佳线程数量:  = (（线程池设定的线程等待时间 + 线程CPU时间） / 线程CPU时间) * cpu数目

这个公式的线程cpu时间是预估的程序单个线程在cpu上运行的时间(通常使用 laodrunner 测试大量运行次数求出平均值)



#### 线程池中的线程初始化

默认情况下,创建线程池之后,线程池中是没有线程的,需要提交任务之后才会创建线程,在实际中如果需要线程池创建只有立即创建线程,可以通过两个方法办到

- prestartCoreThread(): 初始化一个核心线程
- prestartAllCoreThreads(): 初始化所有核心线程

> ThreadPoolExecutor tpe=(ThreadPoolExecutor)service; 
>
> tpe.prestartAllCoreThreads();



#### 线程池的关闭

ThreadPoolExecutor 提供了两个方法用于线程池的关闭,分别是 shutdown()和shutdownNow(),其中

- shutdown():  不会立即终止线程池,而是要等到所有任务缓存队列中的任务都执行完之后才会终止, 但再也不会接受新的任务

- shutdownNow(): 立即终止线程池,并尝试打断正在执行的任务,并且清空任务缓存队列，返回尚未执行的任务


#### 线程池容量的动态调整

   TheradPoolExecuor 提供了动态调整线程池容量大小的方法, setCorePoolSize()和setMaximumPoolSize().

- setCorePoolSize(): 设置核心线程池大小
- setMaximumPoolSize(): 设置最大线程池大小

#### 任务缓存队列和排队策略

在前面我们多次提到了任务缓存队列,即workQueue, 它用来存放等待执行的任务. workQueue 的类型为BlockingQueue,通常可以取下面三种类型:

- ArrayBlockingQueue: 基于数组的先进先出队列,此队列创建必须指定大小;
- LinkedBlockingQueue: 基于链表的先进先出队列,如果创建时没有指定队列大小,则默认为Integer.MAX_VALUE
- SynchronousQueue: 这个队列比较特殊，他不会保存提交的任务,而是将直接新建一个线程来执行新来的任务.

#### 线程池的监控

如果在项目中大规模的使用了线程池,那么必须要有一套监控体系,来知道当前线程池的状态， 当出现问题的时候可以快速的定位到问题,而线程池提供了相应的扩展方法,我们可以通过重写线程池的beforeExecute、afterExecute 和 shutdown  等方式来实现对线程池的监控,

```java
package com.notes.concurrent.threadpool;

import java.util.Date;
import java.util.concurrent.*;
import java.util.function.LongFunction;

/**
 * @author luyanan
 * @since 2019/8/19
 * <p>线程池的监控</p>
 **/
public class ThreadPoolMonitor extends ThreadPoolExecutor {


    /**
     * <p>保存任务开始执行的时间,当任务结束时,用任务结束时间减去开始时间 计算任务执行时间</p>
     *
     * @author luyanan
     * @since 2019/8/19
     */
    private ConcurrentHashMap<String, Date> startTimes;

    public ThreadPoolMonitor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
        this.startTimes = new ConcurrentHashMap<>();
    }


    @Override
    public void shutdown() {
        System.out.println("已经执行的任务数:" + this.getCompletedTaskCount() + ",当前活动线程数:" + this.getActiveCount() + ",当前排队线程数:"
                + this.getQueue().size());
        super.shutdown();
    }


    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        startTimes.put(String.valueOf(r.hashCode()), new Date());
        super.beforeExecute(t, r);
    }


    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        Date startDate = startTimes.remove(String.valueOf(r.hashCode()));

        Date finishDate = new Date();

        Long diff = finishDate.getTime() - startDate.getTime();

        //  统计任务耗时,初始线程数,核心线程数,正在执行线程数
        // 已完成线程数，任务总数,队列里缓存的任务数量
        // 池中存在的最大线程数,最大允许线程数量,线程空闲时间,线程池是否关闭,线程池是否终止

        System.out.println("任务耗时:" + diff);
        System.out.println("初始线程数:" + this.getPoolSize());
        System.out.println("核心线程数:" + this.getCorePoolSize());
        System.out.println("正在执行的任务数量:" + this.getActiveCount());
        System.out.println("已经执行的任务数量:" + this.getCompletedTaskCount());
        System.out.println("任务总数:" + this.getTaskCount());
        System.out.println("最大允许的线程数:" + this.getMaximumPoolSize());
        System.out.println("线程空闲时间" + this.getKeepAliveTime(TimeUnit.SECONDS));
        super.afterExecute(r, t);
    }


    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolMonitor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<>());
    }
}

```

测试

```java
package com.notes.concurrent.threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author luyanan
 * @since 2019/8/19
 * <p></p>
 **/
public class ThreadPoolMonitorTest implements Runnable {

    public static void main(String[] args) {

        ExecutorService executorService = ThreadPoolMonitor.newCachedThreadPool();
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ThreadPoolMonitorTest());
        }
        executorService.shutdown();
    }

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

结果

```
已经执行的任务数:0,当前活动线程数:100,当前排队线程数:0
任务耗时:1001
初始线程数:100
核心线程数:0
正在执行的任务数量:100
已经执行的任务数量:0
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1001
初始线程数:99
核心线程数:0
正在执行的任务数量:99
已经执行的任务数量:1
任务总数:100
任务耗时:1002
最大允许的线程数:2147483647
任务耗时:1003
任务耗时:1003
任务耗时:1002
初始线程数:99
初始线程数:99
线程空闲时间60
------------------------------------------------------
任务耗时:1003
初始线程数:98
初始线程数:99
核心线程数:0
核心线程数:0
核心线程数:0
任务耗时:1002
核心线程数:0
初始线程数:99
正在执行的任务数量:98
任务耗时:1002
初始线程数:98
任务耗时:1002
初始线程数:98
正在执行的任务数量:98
正在执行的任务数量:98
正在执行的任务数量:98
已经执行的任务数量:2
已经执行的任务数量:2
核心线程数:0
核心线程数:0
初始线程数:98
核心线程数:0
任务耗时:1002
已经执行的任务数量:2
核心线程数:0
任务总数:100
初始线程数:98
正在执行的任务数量:98
正在执行的任务数量:98
正在执行的任务数量:98
任务总数:100
任务总数:100
已经执行的任务数量:2
最大允许的线程数:2147483647
最大允许的线程数:2147483647
已经执行的任务数量:2
已经执行的任务数量:2
已经执行的任务数量:2
核心线程数:0
最大允许的线程数:2147483647
正在执行的任务数量:98
线程空闲时间60
------------------------------------------------------
任务耗时:1001
初始线程数:97
核心线程数:0
正在执行的任务数量:97
已经执行的任务数量:3
正在执行的任务数量:98
任务总数:100
任务总数:100
任务耗时:1001
任务总数:100
线程空闲时间60
------------------------------------------------------
任务耗时:1001
初始线程数:96
核心线程数:0
正在执行的任务数量:96
线程空闲时间60
------------------------------------------------------
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
已经执行的任务数量:4
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1002
初始线程数:93
核心线程数:0
初始线程数:97
最大允许的线程数:2147483647
最大允许的线程数:2147483647
已经执行的任务数量:3
任务总数:100
已经执行的任务数量:2
最大允许的线程数:2147483647
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
线程空闲时间60
------------------------------------------------------
核心线程数:0
正在执行的任务数量:91
正在执行的任务数量:93
任务总数:100
已经执行的任务数量:9
已经执行的任务数量:9
线程空闲时间60
------------------------------------------------------
线程空闲时间60
------------------------------------------------------
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
任务总数:100
任务总数:100
最大允许的线程数:2147483647
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
------------------------------------------------------
线程空闲时间60
------------------------------------------------------
任务耗时:1003
初始线程数:85
核心线程数:0
正在执行的任务数量:85
已经执行的任务数量:15
任务总数:100
任务耗时:1004
初始线程数:85
核心线程数:0
正在执行的任务数量:85
已经执行的任务数量:15
任务总数:100
最大允许的线程数:2147483647
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
线程空闲时间60
------------------------------------------------------
任务耗时:1004
任务耗时:1004
初始线程数:83
核心线程数:0
正在执行的任务数量:83
已经执行的任务数量:17
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:82
核心线程数:0
正在执行的任务数量:82
已经执行的任务数量:18
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1006
初始线程数:81
核心线程数:0
正在执行的任务数量:81
已经执行的任务数量:19
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1007
初始线程数:80
核心线程数:0
正在执行的任务数量:80
已经执行的任务数量:20
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1008
任务耗时:1007
任务耗时:1007
任务耗时:1007
初始线程数:79
核心线程数:0
正在执行的任务数量:79
初始线程数:79
核心线程数:0
已经执行的任务数量:21
正在执行的任务数量:79
初始线程数:79
初始线程数:79
核心线程数:0
已经执行的任务数量:21
任务总数:100
任务总数:100
正在执行的任务数量:79
核心线程数:0
已经执行的任务数量:21
最大允许的线程数:2147483647
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1008
初始线程数:77
核心线程数:0
正在执行的任务数量:77
已经执行的任务数量:23
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
正在执行的任务数量:79
已经执行的任务数量:24
线程空闲时间60
------------------------------------------------------
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1008
初始线程数:74
核心线程数:0
正在执行的任务数量:74
已经执行的任务数量:26
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1008
初始线程数:73
核心线程数:0
正在执行的任务数量:73
已经执行的任务数量:27
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1010
初始线程数:72
核心线程数:0
正在执行的任务数量:72
已经执行的任务数量:28
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1010
初始线程数:71
核心线程数:0
正在执行的任务数量:71
已经执行的任务数量:29
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1010
初始线程数:70
任务耗时:1010
初始线程数:70
核心线程数:0
正在执行的任务数量:70
已经执行的任务数量:30
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
核心线程数:0
任务耗时:1009
初始线程数:69
核心线程数:0
正在执行的任务数量:69
已经执行的任务数量:31
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
正在执行的任务数量:68
已经执行的任务数量:32
任务耗时:1009
初始线程数:68
核心线程数:0
正在执行的任务数量:68
已经执行的任务数量:32
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1010
任务耗时:1010
任务耗时:1010
任务耗时:1010
任务耗时:1010
任务耗时:1010
任务耗时:1010
任务耗时:1010
任务总数:100
初始线程数:67
核心线程数:0
任务耗时:1010
正在执行的任务数量:67
初始线程数:67
核心线程数:0
初始线程数:67
核心线程数:0
正在执行的任务数量:67
已经执行的任务数量:33
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:66
核心线程数:0
正在执行的任务数量:66
已经执行的任务数量:34
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:67
核心线程数:0
正在执行的任务数量:65
已经执行的任务数量:35
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:64
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
正在执行的任务数量:63
已经执行的任务数量:37
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:67
核心线程数:0
核心线程数:0
正在执行的任务数量:62
初始线程数:67
核心线程数:0
已经执行的任务数量:38
已经执行的任务数量:33
任务总数:100
任务总数:100
初始线程数:67
核心线程数:0
任务耗时:1010
最大允许的线程数:2147483647
最大允许的线程数:2147483647
正在执行的任务数量:62
正在执行的任务数量:62
已经执行的任务数量:38
线程空闲时间60
------------------------------------------------------
线程空闲时间60
------------------------------------------------------
初始线程数:62
核心线程数:0
正在执行的任务数量:62
任务总数:100
最大允许的线程数:2147483647
已经执行的任务数量:38
线程空闲时间60
------------------------------------------------------
任务耗时:1005
任务耗时:1005
任务耗时:1005
任务耗时:1005
初始线程数:59
核心线程数:0
正在执行的任务数量:59
已经执行的任务数量:41
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:59
核心线程数:0
正在执行的任务数量:58
已经执行的任务数量:42
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:59
核心线程数:0
正在执行的任务数量:57
已经执行的任务数量:43
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1021
初始线程数:55
已经执行的任务数量:41
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
正在执行的任务数量:59
已经执行的任务数量:46
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
核心线程数:0
正在执行的任务数量:53
已经执行的任务数量:47
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:52
核心线程数:0
正在执行的任务数量:52
已经执行的任务数量:48
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1020
初始线程数:51
核心线程数:0
正在执行的任务数量:51
已经执行的任务数量:49
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1022
初始线程数:50
核心线程数:0
正在执行的任务数量:50
已经执行的任务数量:50
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1022
初始线程数:49
核心线程数:0
正在执行的任务数量:49
已经执行的任务数量:51
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1023
初始线程数:48
核心线程数:0
正在执行的任务数量:48
已经执行的任务数量:52
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1028
初始线程数:47
核心线程数:0
正在执行的任务数量:47
已经执行的任务数量:53
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1028
初始线程数:46
核心线程数:0
正在执行的任务数量:46
已经执行的任务数量:54
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1030
初始线程数:45
核心线程数:0
正在执行的任务数量:45
已经执行的任务数量:55
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1030
初始线程数:44
核心线程数:0
正在执行的任务数量:44
已经执行的任务数量:56
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1035
初始线程数:43
核心线程数:0
正在执行的任务数量:43
已经执行的任务数量:57
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1036
初始线程数:42
核心线程数:0
正在执行的任务数量:42
已经执行的任务数量:58
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1043
初始线程数:41
核心线程数:0
正在执行的任务数量:41
已经执行的任务数量:59
任务耗时:1043
初始线程数:41
核心线程数:0
正在执行的任务数量:41
已经执行的任务数量:59
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1043
初始线程数:40
核心线程数:0
正在执行的任务数量:40
已经执行的任务数量:60
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1044
初始线程数:38
核心线程数:0
正在执行的任务数量:38
已经执行的任务数量:62
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1044
初始线程数:37
核心线程数:0
正在执行的任务数量:37
已经执行的任务数量:63
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1044
初始线程数:36
核心线程数:0
正在执行的任务数量:36
已经执行的任务数量:64
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1045
任务耗时:1045
初始线程数:35
核心线程数:0
正在执行的任务数量:35
已经执行的任务数量:65
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:34
核心线程数:0
正在执行的任务数量:34
已经执行的任务数量:66
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1046
初始线程数:33
核心线程数:0
正在执行的任务数量:33
已经执行的任务数量:67
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1046
初始线程数:32
核心线程数:0
正在执行的任务数量:32
已经执行的任务数量:68
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1046
初始线程数:31
核心线程数:0
正在执行的任务数量:31
已经执行的任务数量:69
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1047
初始线程数:30
核心线程数:0
正在执行的任务数量:30
已经执行的任务数量:70
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1047
任务耗时:1047
初始线程数:29
核心线程数:0
正在执行的任务数量:29
已经执行的任务数量:71
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:28
核心线程数:0
正在执行的任务数量:28
已经执行的任务数量:72
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1047
初始线程数:27
核心线程数:0
正在执行的任务数量:27
已经执行的任务数量:73
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1047
初始线程数:26
核心线程数:0
正在执行的任务数量:26
已经执行的任务数量:74
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1048
初始线程数:25
核心线程数:0
正在执行的任务数量:25
已经执行的任务数量:75
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1048
初始线程数:24
核心线程数:0
正在执行的任务数量:24
已经执行的任务数量:76
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1048
初始线程数:23
核心线程数:0
正在执行的任务数量:23
已经执行的任务数量:77
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1048
初始线程数:22
核心线程数:0
正在执行的任务数量:22
已经执行的任务数量:78
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1048
初始线程数:21
核心线程数:0
正在执行的任务数量:21
已经执行的任务数量:79
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1049
初始线程数:20
核心线程数:0
正在执行的任务数量:20
已经执行的任务数量:80
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1049
初始线程数:19
核心线程数:0
正在执行的任务数量:19
已经执行的任务数量:81
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1048
初始线程数:18
任务耗时:1048
初始线程数:18
核心线程数:0
正在执行的任务数量:18
已经执行的任务数量:82
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
核心线程数:0
正在执行的任务数量:17
已经执行的任务数量:83
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1049
初始线程数:16
核心线程数:0
正在执行的任务数量:16
已经执行的任务数量:84
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1049
初始线程数:15
核心线程数:0
正在执行的任务数量:15
已经执行的任务数量:85
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1049
初始线程数:14
核心线程数:0
正在执行的任务数量:14
已经执行的任务数量:86
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1049
初始线程数:13
核心线程数:0
正在执行的任务数量:13
已经执行的任务数量:87
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1052
初始线程数:12
核心线程数:0
正在执行的任务数量:12
已经执行的任务数量:88
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1052
初始线程数:11
核心线程数:0
正在执行的任务数量:11
已经执行的任务数量:89
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1052
初始线程数:10
核心线程数:0
任务耗时:1052
初始线程数:10
核心线程数:0
任务耗时:1053
初始线程数:10
任务耗时:1053
初始线程数:10
核心线程数:0
正在执行的任务数量:10
已经执行的任务数量:90
任务总数:100
正在执行的任务数量:10
任务耗时:1053
初始线程数:10
核心线程数:0
任务耗时:1053
初始线程数:10
正在执行的任务数量:10
已经执行的任务数量:90
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1053
初始线程数:9
核心线程数:0
正在执行的任务数量:9
已经执行的任务数量:91
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务耗时:1053
初始线程数:8
核心线程数:0
任务耗时:1053
核心线程数:0
正在执行的任务数量:8
正在执行的任务数量:10
任务耗时:1053
初始线程数:8
核心线程数:0
正在执行的任务数量:8
已经执行的任务数量:92
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
已经执行的任务数量:92
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
初始线程数:8
核心线程数:0
正在执行的任务数量:6
已经执行的任务数量:94
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
正在执行的任务数量:8
已经执行的任务数量:95
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
已经执行的任务数量:90
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
核心线程数:0
正在执行的任务数量:2
已经执行的任务数量:98
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
已经执行的任务数量:92
任务总数:100
最大允许的线程数:2147483647
线程空闲时间60
------------------------------------------------------
```



## Callable/ Future 使用以及原理分析

线程池的执行任务有两种方法,一种是submit,一种是execute,这两个方法是有区别的,我们基于他们的区别来看看

#### execute和submit的区别

##### execute

1. execute 只可以接受一个Runnable的参数
2. execute 如果出现异常会抛出
3. execute没有返回值

##### submit

1. submit 可以接受Runnable和Callable 这两种类型的参数
2. 对于submit 方法,如果传入一个Callable, 可以得到一个Future的返回值
3. submit 方法调用不会抛出异常,除非调用Future.get()

#### Callable/Future 案例演示

Callable/Future 和Thread之类的线程构建最大的区别在于能够很方便的获取线程执行以后的结果,首先来看一个简单的例子

```java
package com.notes.concurrent.threadpool;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @author luyanan
 * @since 2019/8/19
 * <p></p>
 **/
public class CallableDemo implements Callable<String> {


    @Override
    public String call() throws Exception {
        return "1111";
    }


    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableDemo callableDemo = new CallableDemo();
        FutureTask futureTask = new FutureTask(callableDemo);
        new Thread(futureTask).start();
        System.out.println(futureTask.get());
    }
}


```

想一想我们为什么需要使用回调呢? 那么因为结果值是由另一个线程计算的,当前线程不知道结果值什么时候计算完成,所以它传递一个回调接口给计算线程,当计算完成后,调用这个回调接口,环境，回传结果值

这个很多地方有用到,比如Dubbo的异步调用,比如消息中间件的异步通信,等等

利用FutureTask、Callable、Thread 对耗时任务(如查询数据库)做预处理,在需要计算结果之前就启动计算

所以我们来看一下Future/Callable是如何实现的

#### Callable/Future 原理分析

在刚刚实现的demo中,我们用到了两个api,分别是Callable和FutureTask, Callable是一个函数式接口,里面只有一个call方法.子类可以重写这个方法,并且这个方法会有一个返回值

```java
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}

```

#### FutureTask

FutureTask 的类关系图如下：它实现了RunnableFuture接口,那么这个RunnableFuture接口的作用是什么呢?

在讲解FutureTask之前,先看看Callable、Future、FutureTask之间的关系图,如下：

![](http://files.luyanan.com//img/20190820171313.png)

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

RunnableFuture 是接口,它继承了Runnable和Future这两个接口,Runnale太熟悉了,那么Future是什么呢？

Future表示一个任务的生命周期,并提供了相应的方法来判断是否已经完成或者取消,以及获取任务的结果和取消任务等.

```java
public interface Future<V> {

    /**
     * Attempts to cancel execution of this task.  This attempt will
     * fail if the task has already completed, has already been cancelled,
     * or could not be cancelled for some other reason. If successful,
     * and this task has not started when {@code cancel} is called,
     * this task should never run.  If the task has already started,
     * then the {@code mayInterruptIfRunning} parameter determines
     * whether the thread executing this task should be interrupted in
     * an attempt to stop the task.
     *
     * <p>After this method returns, subsequent calls to {@link #isDone} will
     * always return {@code true}.  Subsequent calls to {@link #isCancelled}
     * will always return {@code true} if this method returned {@code true}.
     *
     * @param mayInterruptIfRunning {@code true} if the thread executing this
     *                              task should be interrupted; otherwise, in-progress tasks are allowed
     *                              to complete
     * @return {@code false} if the task could not be cancelled,
     * typically because it has already completed normally;
     * {@code true} otherwise
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * Returns {@code true} if this task was cancelled before it completed
     * normally.
     *
     * @return {@code true} if this task was cancelled before it completed
     */
    /**
     * <p>当前的Future 是否被取消,返回ture 表示已经被取消</p>
     *
     * @return {@link boolean}
     * @author luyanan
     * @since 2019/8/20
     */
    boolean isCancelled();

    /**
     * Returns {@code true} if this task completed.
     *
     * Completion may be due to normal termination, an exception, or
     * cancellation -- in all of these cases, this method will return
     * {@code true}.
     *
     * @return {@code true} if this task completed
     */
    /**
     * <p>当前Future是否已经结束,包括运行完成,抛出异常以及取消,都表示当前Future 已经结束</p>
     *
     * @return {@link boolean}
     * @author luyanan
     * @since 2019/8/20
     */
    boolean isDone();

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     *
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     */
    /**
     * <p>获取Future的结果值,如果当前Future还没有结束,那么当前线程就等待
     * 直到Future 运行结束,那么会唤醒等待结果值的线程的</p>
     *
     * @return {@link V}
     * @author luyanan
     * @since 2019/8/20
     */
    V get() throws InterruptedException, ExecutionException;

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     *
     * @param timeout the maximum time to wait
     * @param unit    the time unit of the timeout argument
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException    if the computation threw an
     *                               exception
     * @throws InterruptedException  if the current thread was interrupted
     *                               while waiting
     * @throws TimeoutException      if the wait timed out
     */
    /**
     * <p>获取Future的结果值，与get()相比较多了允许设置超时时间</p>
     *
     * @param timeout
     * @param unit
     * @return {@link V}
     * @author luyanan
     * @since 2019/8/20
     */
    V get(long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException;
}

```

分析到这里我们其实已经有一些初步的头绪了,FutureTask 是Runnable和Future的结合体,如果我们把Runnable 比作是生产者,Future比作是消费者的话,那么FutureTask 是被这两者共享的,生产者运行run方法计算结果,消费者通过get方法获取结果.

作为生产者消费者模式,有一个很重要的机制,就是如果生产者数据还没有准备的时候,消费者会被阻塞,当生产者数据准备好了之后,会唤醒消费者继续执行

#### state的含义

表示FutureTask 当前的状态,分为七种状态

```java
  // NEW 新建状态,表示这个FutureTask 还没有开始运行
    private static final int NEW          = 0;
    // COMPLETING 完成状态,表示 FutureTask 任务已经计算完成了,但是还有一些后续操作,例如唤醒等待线程操作,还没有完成
    private static final int COMPLETING   = 1;
    // FutureTask 任务完结,正常完成,没有发生异常
    private static final int NORMAL       = 2;
    // FutureTask 任务完结，因为发生异常
    private static final int EXCEPTIONAL  = 3;
    // FutureTask 任务完结，因为取消任务
    private static final int CANCELLED    = 4;
    // FutureTask 任务完成,也是取消任务,不过发起了中断运行任务线程的中断请求
    private static final int INTERRUPTING = 5;
    // FutureTask 任务完结,也是取消任务,已经完成了中断运行任务线程的中断请求
    private static final int INTERRUPTED  = 6;
    
```

#### run 方法

```java
 public void run() {
        // 如果状态state 不是 New或者设置 runner 值失败,表示有别的线程再次之前调用run方法,并成功的设置了runner值
        // 保证了只有一个线程可以运行try 代码块中的代码
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            // 只有c不为null 且state 状态为NEW的情况
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    // 调用 callable的call方法,并获取到返回值
                    result = c.call();
                    // 运行成功
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    // 设置异常结果
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }


```

其实run方法 作用很简单,就是调用callable 的call方法返回结果值result, 根据是否发生异常,调用set(result)或setExeception(ex) 方法表示FutureTask任务完结

不过因为FutureTask 任务都是在多线程环境中使用,所以要注意并发问题.注意在run方法中我们没有使用 synchronzied 代码块或者lock来解决并发问题,而是使用了CAS 这个乐观锁来实现并发,保证只有一个线程能运行FutureTask任务.

#### get方法

get方法就是阻塞获取线程执行结果,这里主要做了两件事情

1. 判断当前状态,如果状态小于等于COMPLETING, 表示FutureTask 任务还没有完结，所以调用awaitDone 方法,让当前线程等待.
2. report 返回结果值或者抛出异常

```java
    public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s <= COMPLETING)
            s = awaitDone(false, 0L);
        return report(s);
    }
    
```

#### awaitDone

如果当前的结果还没有执行完,把当前线程插入到等待队列

```java
 private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        WaitNode q = null;
        // 节点是够已经添加
        boolean queued = false;
        for (;;) {
            // 如果当前线程中断标识位是true
            // 那么从列表中移除节点q,并抛出InterruptedException 异常,
            if (Thread.interrupted()) {
                removeWaiter(q);
                throw new InterruptedException();
            }

            int s = state;
            // 当状态大于COMPLETING时,表示FutureTask 任务已经结束
            if (s > COMPLETING) {
                if (q != null)
                    // 将节点q 设置为null,因为线程没有阻塞等待
                    q.thread = null;
                return s;
            }
            //  表示还有一些后续操作还没有执行结束,那么当前线程让出执行权
            else if (s == COMPLETING) // cannot time out yet
                Thread.yield();
            // 表示状态是NEW，那么就需要将当前线程阻塞等待
            // 就是将他插入等待线程链表中
            else if (q == null)
                q = new WaitNode();
            else if (!queued)
                // 使用CAS函数将新节点添加到链表中,如果添加失败,那么queued 为false
                // 下次循环时会继续添加,直到成功
                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                     q.next = waiters, q);
            // 如果timed 为true 表示需要设置超时
            else if (timed) {
                nanos = deadline - System.nanoTime();
                if (nanos <= 0L) {
                    removeWaiter(q);
                    return state;
                }
                // 让当前线程等待 nanos时间
                LockSupport.parkNanos(this, nanos);
            }
            else
                LockSupport.park(this);
        }
    }
```

#### report

report 方法就是根据传入的状态值s 来决定是抛出异常还是返回结果值,这两种情况都表示FutureTask 完结了

```java
 private V report(int s) throws ExecutionException {
        // 表示call的返回值
        Object x = outcome;
        // 表示正常完结状态,所以返回返回值
        if (s == NORMAL)
            return (V)x;
        // 大于等于CANCELLED 都表示手动取消 FutureTask任务,所以抛出 CancellationException 异常
        if (s >= CANCELLED)
            throw new CancellationException();
        // 否则就是运行过程中发生了异常,这里就抛出这个异常
        throw new ExecutionException((Throwable)x);
    }
    
```

####   线程池对于Future/Callable的执行

我们现在再来看一下线程池里面的submit 方法,就会很清楚了

```java
package com.notes.concurrent.threadpool;

import java.util.concurrent.*;

/**
 * @author luyanan
 * @since 2019/8/19
 * <p></p>
 **/
public class CallableDemo implements Callable<String> {


    @Override
    public String call() throws Exception {
        return "1111";
    }


    public static void main(String[] args) throws ExecutionException, InterruptedException {
//        CallableDemo callableDemo = new CallableDemo();
//        FutureTask futureTask = new FutureTask(callableDemo);
//        new Thread(futureTask).start();
//        System.out.println(futureTask.get());

        ExecutorService executorService = Executors.newFixedThreadPool(1);
        CallableDemo callableDemo = new CallableDemo();
        Future<String> submit = executorService.submit(callableDemo);
        System.out.println(submit.get());

        executorService.shutdown();
    }
}

```

#### AbstractExecutorService.submit

调用抽象类中的submit 方法,这里其实相对于execute 方法来说,至多做了一步操作,就是封装了一个RunnableFuture,

```java
   public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
```

#### ThreadpoolExecutor.execute

然后调用execute 方法,这里的逻辑前面分析过了,会通过worker 线程来调用ftask的 run方法,而这个ftask 其实就是FutureTask里面最终实现的逻辑





