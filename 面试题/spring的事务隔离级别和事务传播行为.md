##   spring的事务隔离级别和事务传播行为

###  事务隔离级别

- DEFAULT 

  > 使用底层数据库默认的隔离级别,大部分数据库默认的隔离级别都是`READ_COMMITED`

- READ_UNCOMMITED 

  > 允许事务读取未被其他事务提交的修改、可能会出现脏读、幻读、不可重复读

- READ_COMMITED 

  > 只允许事务读取已经被事务提交的更改,可以避免脏读.但不可重复读和幻读问题仍然可能出现. 

- REPEATABLE_READ

  > 确保事务可以多次从一个字段中读取相同的值,在这个事务持续期间, 禁止其他事务对这个字段进行更新,可以避免脏读和不可重复读, 但是幻读问题仍然存在. 

- SERIALIZABLE 

  > 确保事务可以从一个表中读取相同的行, 在这个事务持续期间, 禁止其他事务对该表执行插入、更新、删除. 所有的并发问题都能避免, 但是性能较低. 

 事务的隔离级别需要底层数据库引擎的支持,而不是应用程序或者框架的支持. 

1. Oracle 支持2种事务隔离级别: `READ_COMMITED`，`SERIALIZABLE`. 默认是 `READ_COMMITED`
2. Mysql 支持4种事务隔离级别, 默认是`REPEATABLE_READ` . 

```mysql

msyql 查看隔离级别：
select @@tx_isolation;
设置隔离级别：
set session transaction isolation level serializable;
```



###  事务传播机制

​    事务方法被另一个事务方法调用的时候, 必须指定事务应该如何传播.例如方法可能继续在现有事务中运行, 也可能开启一个新的事务, 并在自己的事务运行. spring中的事务传播行为可以由传播属性指定. Spring指定了7种传播行为. 

 

| REQUIRED      | 如何有事务在运行, 当前的方法就在这个事务中运行, 否则就重新开一个新的事务,默认传播行为. |
| ------------- | ------------------------------------------------------------ |
| REQUIRED_NEW  | 当前方法必须启动新的事务, 并在自己的事务中运行, 如果有事务在运行, 则将它挂起. |
| SUPPORTS      | 如果有事务在运行, 当前的方法就是在这个事务中运行, 否则可以不运行在事务中. |
| NOT_SUPPORTED | 表示该方法不应该运行在事务中, 如果存在当前事务,在该方法运行期间, 当前事务将被挂起. |
| MANDATORY     | 当前的方法必须运行在事务内部,如果没有正在运行的事务,将会抛出异常. |
| NEVER         | 当前方法不应该运行在事务中, 如果有运行的事务, 就抛出异常.    |
| NESTED        | 如果有事务在运行, 当前的方法就应该在这个事务的嵌套事务内运行. 嵌套的事务可以独立于当前事务进行单独的提交或者回滚. 如果当前事务不存在, 那么其行为与`PROPAGATION_REQUIRED`一样. |
